
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   
      <!--
This HTML is auto-generated from an M-file.
To make changes, update the M-file and republish this document.
      -->
      <title>Tutorial for xml_io_tools Package</title>
      <meta name="generator" content="MATLAB 7.7">
      <meta name="date" content="2010-05-04">
      <meta name="m-file" content="xml_tutorial_script"><style type="text/css">

body {
  background-color: white;
  margin:10px;
}

h1 {
  color: #990000; 
  font-size: x-large;
}

h2 {
  color: #990000;
  font-size: medium;
}

/* Make the text shrink to fit narrow windows, but not stretch too far in 
wide windows. */ 
p,h1,h2,div.content div {
  max-width: 600px;
  /* Hack for IE6 */
  width: auto !important; width: 600px;
}

pre.codeinput {
  background: #EEEEEE;
  padding: 10px;
}
@media print {
  pre.codeinput {word-wrap:break-word; width:100%;}
} 

span.keyword {color: #0000FF}
span.comment {color: #228B22}
span.string {color: #A020F0}
span.untermstring {color: #B20000}
span.syscmd {color: #B28C00}

pre.codeoutput {
  color: #666666;
  padding: 10px;
}

pre.error {
  color: red;
}

p.footer {
  text-align: right;
  font-size: xx-small;
  font-weight: lighter;
  font-style: italic;
  color: gray;
}

  </style></head>
   <body>
      <div class="content">
         <h1>Tutorial for xml_io_tools Package</h1>
         <!--introduction-->
         <p><b>By Jarek Tuszynski</b></p>
         <p>Package xml_io_tools can read XML files into MATLAB struct and writes MATLAB data types to XML files with help of simple interface
            to MATLAB's xmlwrite and xmlread functions.
         </p>
         <p>Two function to simplify reading and writing XML files from MATLAB:</p>
         <div>
            <ul>
               <li>Function xml_read first calls MATLAB's xmlread function and than converts its output ('Document Object Model' tree of Java
                  objects) to tree of MATLAB struct's. The output is in the format of nested structs and cells. In the output data structure
                  field names are based on XML tags.
               </li>
            </ul>
         </div>
         <div>
            <ul>
               <li>Function xml_write first convert input tree of MATLAB structs and cells and other types to tree of 'Document Object Model'
                  nodes, and then writes resulting object to XML file using MATLAB's xmlwrite function. .
               </li>
            </ul>
         </div>
         <!--/introduction-->
         <h2>Contents</h2>
         <div>
            <ul>
               <li><a href="#1">This package can:</a></li>
               <li><a href="#2">This package does not:</a></li>
               <li><a href="#3">Change History</a></li>
               <li><a href="#4">Licence</a></li>
               <li><a href="#5">Write XML file based on a Struct using "xml_write"</a></li>
               <li><a href="#6">Read XML file producing a Struct using "xml_read"</a></li>
               <li><a href="#7">"Pref.XmlEngine" flag in "xml_write"</a></li>
               <li><a href="#8">Writing Struct with MATLAB arrays</a></li>
               <li><a href="#9">Read Struct with MATLAB arrays</a></li>
               <li><a href="#10">"Pref.StructItem" flag in "xml_write"</a></li>
               <li><a href="#16">"Pref.CellItem" flag in "xml_write"</a></li>
               <li><a href="#20">"Pref.NoCells" flag in "xml_read"</a></li>
               <li><a href="#24">"Pref.ItemName" flag in "xml_write"</a></li>
               <li><a href="#26">"Pref.ItemName" flag in "xml_read"</a></li>
               <li><a href="#28">"Pref.CellItem" flag in "xml_read"</a></li>
               <li><a href="#33">"Pref.Str2Num" flag in xml_read</a></li>
               <li><a href="#40">"Pref.PreserveSpace" flag in xml_write</a></li>
               <li><a href="#43">"Pref.PreserveSpace" flag in xml_read</a></li>
               <li><a href="#45">Write XML files with ATTRIBUTEs</a></li>
               <li><a href="#47">"Pref.Str2Num" flag in file with ATTRIBUTEs</a></li>
               <li><a href="#53">Write XML files with COMMENTs</a></li>
               <li><a href="#59">Write XML files with PROCESSING_INSTRUCTIONs</a></li>
               <li><a href="#65">Write XML files with CDATA Sections</a></li>
               <li><a href="#67">Write XML files with special characters in TAG names</a></li>
               <li><a href="#71">Write XML files with Namespaces</a></li>
               <li><a href="#73">"Pref.KeepNS" flag in "xml_read"</a></li>
               <li><a href="#75">Read XML files with special node types</a></li>
               <li><a href="#78">"Pref.ReadAttr" flag in "xml_read"</a></li>
               <li><a href="#79">"Pref.ReadSpec" flag in "xml_read"</a></li>
               <li><a href="#80">"Pref.RootOnly" flag in "xml_read"</a></li>
               <li><a href="#81">"Pref.RootOnly" flag in "xml_write"</a></li>
               <li><a href="#83">"Pref.NumLevels" flag in "xml_read"</a></li>
               <li><a href="#86">Create DOM object based on a Struct using "xml_write"</a></li>
               <li><a href="#88">Convert DOM object to Struct using "xml_read"</a></li>
               <li><a href="#89">Write XML file based on a DOM using "xml_write_xerces"</a></li>
               <li><a href="#90">Write XML to string instead of a file</a></li>
               <li><a href="#91">Write XML file with embedded binary data encoded as Base64</a></li>
               <li><a href="#92">Read XML file with embedded binary data encoded as Base64</a></li>
            </ul>
         </div>
         <h2>This package can:<a name="1"></a></h2>
         <div>
            <ul>
               <li>Read most XML files, created inside and outside of MATLAB environment,   and convert them to MATLAB data structures.</li>
               <li>Write any MATLAB's struct tree to XML file</li>
               <li>Handle XML attributes</li>
               <li>Handle special XML nodes like comments, processing instructions and   CDATA sections</li>
               <li>Be studied, modified, customized, rewritten and used in other packages   without any limitations. All code is included and
                  documented. Software   is distributed under MIT Licence (included).
               </li>
            </ul>
         </div>
         <h2>This package does not:<a name="2"></a></h2>
         <div>
            <ul>
               <li>Guarantee to recover the same Matlab objects that were saved. If you need to be able to recover carbon copy of the structure
                  that was saved than you will have to use one of the packages that uses special set of tags saved as xml attributes that help
                  to guide the parsing of XML code. This package does not use those tags.
               </li>
               <li>Guarantee to work with older versions of MATLAB. Functions do not work with versions of MATLAB prior to 7.1 (26-Jul-2005).
                  Versions starting with 7.1 seem to work on my machine, which have current java engine and libraries.
               </li>
            </ul>
         </div>
         <h2>Change History<a name="3"></a></h2>
         <div>
            <ul>
               <li>2006-11-06 - original version</li>
               <li>2006-11-26 - corrected xml_write to handle writing Matlab's column   arrays to xml files. Bug discovered and diagnosed by
                  Kalyan Dutta.
               </li>
               <li>2006-11-28 - made changes to handle special node types like:   COMMENTS and CDATA sections</li>
               <li>2007-03-12 - Writing CDATA sections still did not worked. The problem   was diagnosed and fixed by Alberto Amaro. The fix
                  involved rewriting   xmlwrite to use Apache Xerces java files directly instead of MATLAB's   XMLUtils java class.
               </li>
               <li>2007-06-21 - Fixed problem reported by Anna Kelbert in Reviews about   not writing attributes of ROOT node. Also: added support
                  for Processing   Instructions, added support for global text nodes: Processing   Instructions and comments, allowed writing
                  tag names with special   characters
               </li>
               <li>2007-07-20 - Added tutorial script file. Extended support for global   text nodes. Added more Preference fields.</li>
               <li>2008-01-23 - Fixed problem reported by Anna Krewet of converting dates   in format '2007-01-01' to numbers. Improved and added
                  warning messages.   Added detection of old Matlab versions incompatible with the library.   Expanded documentation.
               </li>
               <li>2008-06-23 - Fixed problem with writing 1D array reported by Mark Neil.   Extended xml_read's Pref.Num2Str to 3 settings (never,
                  smart and always)   for better control. Added parameter Pref.KeepNS for keeping or ignoring   namespace data when reading.
                  Fixed a bug related to writing 2D cell   arrays brought up by Andrej's Mosat review.
               </li>
               <li>2008-09-11 - Resubmitting last upload - zip file is still old</li>
               <li>2009-02-26 - Small changes. More error handling. More robust in case of   large binary objects. Added support for Base64 encoding/decoding
                  of   binary objects (using functions by Peter J. Acklam).
               </li>
               <li>2009-06-26 - changes to xml_read: added CellItem parameter to allow   better control of reading files with 'item' notation
                  (see comment by   Shlomi); changed try-catch statements so xml_read would work for mablab   versions prior to 7.5 (see Thomas
                  Pilutti comment)
               </li>
               <li>2009-12-03 - added PreserveSpace parameter for contolling empty string   handling as suggested by Sebastiaan. Fix suggested
                  by Michael Murphy.   Fixed number recognition code as suggested by Yuan Ren.
               </li>
               <li>2010-05-04 - implemented fixes suggested by Dylan Reynolds from Airbus.</li>
            </ul>
         </div>
         <h2>Licence<a name="4"></a></h2>
         <p>The package is distributed under MIT License</p><pre class="codeinput">format <span class="string">compact</span>; <span class="comment">% viewing preference</span>
clear <span class="string">variables</span>;
type(<span class="string">'license.txt'</span>)
</pre><pre class="codeoutput">
Copyright (c) 2007, Jaroslaw Tuszynski
All rights reserved.

Redistribution and use in source and binary forms, with or without 
modification, are permitted provided that the following conditions are 
met:

    * Redistributions of source code must retain the above copyright 
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright 
      notice, this list of conditions and the following disclaimer in 
      the documentation and/or other materials provided with the distribution
      
THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
POSSIBILITY OF SUCH DAMAGE.

</pre><h2>Write XML file based on a Struct using "xml_write"<a name="5"></a></h2>
         <p>Any MATLAB data struct can be saved to XML file.</p><pre class="codeinput">MyTree=[];
MyTree.MyNumber = 13;
MyTree.MyString = <span class="string">'Hello World'</span>;
xml_write(<span class="string">'test.xml'</span>, MyTree);
type(<span class="string">'test.xml'</span>)
</pre><pre class="codeoutput">
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;a&gt;[0 0]&lt;/a&gt;
</pre><h2>Read XML file producing a Struct using "xml_read"<a name="6"></a></h2><pre class="codeinput">[tree treeName] = xml_read (<span class="string">'test.xml'</span>);
disp([treeName{1} <span class="string">' ='</span>])
gen_object_display(tree)
</pre><pre class="codeoutput">MyTree =
    MyNumber: [13]
    MyString: 'Hello World'
</pre><h2>"Pref.XmlEngine" flag in "xml_write"<a name="7"></a></h2>
         <p>Occasionaly some operations are performed better by Apache Xerces XML engine than default xmlread function. That is why xml_write
            provide an option for choosing the underlaying xml engine. Code below performs the same operation as the previous section
            but using Apache Xerces XML engine. Notice that in this case name of root element was passed as variable and not extracted
            from the variable name.
         </p><pre class="codeinput">Pref=[]; Pref.XmlEngine = <span class="string">'Xerces'</span>;  <span class="comment">% use Xerces xml generator directly</span>
xml_write(<span class="string">'test.xml'</span>, MyTree, <span class="string">'TreeOfMine'</span>, Pref);
type(<span class="string">'test.xml'</span>)
</pre><pre class="codeoutput">
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;TreeOfMine&gt;
    &lt;MyNumber&gt;13&lt;/MyNumber&gt;
    &lt;MyString&gt;Hello World&lt;/MyString&gt;
&lt;/TreeOfMine&gt;

</pre><h2>Writing Struct with MATLAB arrays<a name="8"></a></h2><pre class="codeinput">MyTree=[];
MyTree.Num_1x1 = 13;
MyTree.Vec_1x3 = [1 2 3];
MyTree.Vec_4x1 = [1; 2; 3; 4];
MyTree.Mat_2x2 = [1, 2; 3, 4];         <span class="comment">% 2D Matrix</span>
MyTree.Cube_3D = reshape(1:8,[2 2 2]); <span class="comment">% 3D array</span>
MyTree.String1 = <span class="string">'[2003 10 30]'</span>;       <span class="comment">% array with    [] brackets</span>
MyTree.String2 =  <span class="string">'2003 10 30'</span>;        <span class="comment">% array without [] brackets</span>
xml_write(<span class="string">'test.xml'</span>, MyTree);
type(<span class="string">'test.xml'</span>)
</pre><pre class="codeoutput">
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;MyTree&gt;
   &lt;Num_1x1&gt;13&lt;/Num_1x1&gt;
   &lt;Vec_1x3&gt;[1 2 3]&lt;/Vec_1x3&gt;
   &lt;Vec_4x1&gt;[1; 2; 3; 4]&lt;/Vec_4x1&gt;
   &lt;Mat_2x2&gt;[1 2; 3 4]&lt;/Mat_2x2&gt;
   &lt;Cube_3D&gt;1 2 3 4 5 6 7 8&lt;/Cube_3D&gt;
   &lt;String1&gt;[2003 10 30]&lt;/String1&gt;
   &lt;String2&gt;2003 10 30&lt;/String2&gt;
&lt;/MyTree&gt;
</pre><h2>Read Struct with MATLAB arrays<a name="9"></a></h2>
         <p>Notice that 'Cube_3D' did not preserve original dimentions</p><pre class="codeinput">[tree treeName] = xml_read (<span class="string">'test.xml'</span>);
disp([treeName{1} <span class="string">' ='</span>])
gen_object_display(tree)
</pre><pre class="codeoutput">MyTree =
    Num_1x1: [13]
    Vec_1x3: [1  2  3]
    Vec_4x1: [4x1 double]
    Mat_2x2: [2x2 double]
    Cube_3D: [1  2  3  4  5  6  7  8]
    String1: [2003    10    30]
    String2: [2003    10    30]
</pre><h2>"Pref.StructItem" flag in "xml_write"<a name="10"></a></h2>
         <p><b>Create a simple structure with arrays of struct's</b></p><pre class="codeinput">MyTree = [];
MyTree.a(1).b = <span class="string">'jack'</span>;
MyTree.a(2).b = <span class="string">'john'</span>;
gen_object_display(MyTree)
</pre><pre class="codeoutput">    a: [1x2 struct]
       b: 'jack'

       b: 'john'

</pre><p><b>Write XML with "StructItem = true" (default).  Notice single 'a' section and multiple 'item' sub-sections. Those subsections
               are used to store array elements</b></p><pre class="codeinput">wPref.StructItem = true;
xml_write(<span class="string">'test.xml'</span>, MyTree, <span class="string">'MyTree'</span>,wPref);
type(<span class="string">'test.xml'</span>)
fprintf(<span class="string">'\nxml_read output:\n'</span>)
gen_object_display(xml_read (<span class="string">'test.xml'</span>))
</pre><pre class="codeoutput">
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;MyTree&gt;
   &lt;a&gt;
      &lt;item&gt;
         &lt;b&gt;jack&lt;/b&gt;
      &lt;/item&gt;
      &lt;item&gt;
         &lt;b&gt;john&lt;/b&gt;
      &lt;/item&gt;
   &lt;/a&gt;
&lt;/MyTree&gt;

xml_read output:
    a: [2x1 struct]
       b: 'jack'

       b: 'john'

</pre><p><b>Write XML with "StructItem = false". Notice multiple 'a' sections</b></p><pre class="codeinput">wPref.StructItem = false;
xml_write(<span class="string">'test.xml'</span>, MyTree, <span class="string">'MyTree'</span>,wPref);
type(<span class="string">'test.xml'</span>)
fprintf(<span class="string">'\nxml_read output:\n'</span>)
gen_object_display(xml_read (<span class="string">'test.xml'</span>))
</pre><pre class="codeoutput">
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;MyTree&gt;
   &lt;a&gt;
      &lt;b&gt;jack&lt;/b&gt;
   &lt;/a&gt;
   &lt;a&gt;
      &lt;b&gt;john&lt;/b&gt;
   &lt;/a&gt;
&lt;/MyTree&gt;

xml_read output:
    a: [2x1 struct]
       b: 'jack'

       b: 'john'

</pre><p><b>Notice that xml_read function produced the same struct when reading both files</b></p>
         <p><b>Potential problems with "StructItem = true":</b></p><pre class="codeinput">wPref.StructItem = true;
MyTree1 = []; MyTree1.a.b    = <span class="string">'jack'</span>;
MyTree2 = []; MyTree2.a(1).b = <span class="string">'jack'</span>;
MyTree3 = []; MyTree3.a(2).b = <span class="string">'jack'</span>;
xml_write(<span class="string">'test.xml'</span>, MyTree1, [], wPref); type(<span class="string">'test.xml'</span>);
xml_write(<span class="string">'test.xml'</span>, MyTree2, [], wPref); type(<span class="string">'test.xml'</span>);
xml_write(<span class="string">'test.xml'</span>, MyTree3, [], wPref); type(<span class="string">'test.xml'</span>);
</pre><pre class="codeoutput">
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;MyTree1&gt;
   &lt;a&gt;
      &lt;b&gt;jack&lt;/b&gt;
   &lt;/a&gt;
&lt;/MyTree1&gt;

&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;MyTree2&gt;
   &lt;a&gt;
      &lt;b&gt;jack&lt;/b&gt;
   &lt;/a&gt;
&lt;/MyTree2&gt;

&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;MyTree3&gt;
   &lt;a&gt;
      &lt;item&gt;
         &lt;b/&gt;
      &lt;/item&gt;
      &lt;item&gt;
         &lt;b&gt;jack&lt;/b&gt;
      &lt;/item&gt;
   &lt;/a&gt;
&lt;/MyTree3&gt;
</pre><p><b>Notice that MyTree1 and MyTree2 produce identical files with no 'items', while MyTree2 and MyTree3 produce very different
               file structures. It was pointed out to me that files produced from MyTree2 and MyTree3 can not belong to the same schema,
               which can be a problem. The solution is to use cells.</b></p><pre class="codeinput">wPref.CellItem = true;
wPref.NoCells  = true;
MyTree2 = []; MyTree2.a{1}.b = <span class="string">'jack'</span>;
MyTree3 = []; MyTree3.a{2}.b = <span class="string">'jack'</span>;
xml_write(<span class="string">'test.xml'</span>, MyTree2, [], wPref); type(<span class="string">'test.xml'</span>);
xml_write(<span class="string">'test.xml'</span>, MyTree3, [], wPref); type(<span class="string">'test.xml'</span>);
</pre><pre class="codeoutput">
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;MyTree2&gt;
   &lt;a&gt;
      &lt;item&gt;
         &lt;b&gt;jack&lt;/b&gt;
      &lt;/item&gt;
   &lt;/a&gt;
&lt;/MyTree2&gt;

&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;MyTree3&gt;
   &lt;a&gt;
      &lt;item/&gt;
      &lt;item&gt;
         &lt;b&gt;jack&lt;/b&gt;
      &lt;/item&gt;
   &lt;/a&gt;
&lt;/MyTree3&gt;
</pre><h2>"Pref.CellItem" flag in "xml_write"<a name="16"></a></h2>
         <p><b>Create a simple structure with cell arrays</b></p><pre class="codeinput">MyTree = [];
MyTree.a = {<span class="string">'jack'</span>, <span class="string">'john'</span>};
disp(MyTree)
</pre><pre class="codeoutput">    a: {'jack'  'john'}
</pre><p><b>Write XML with "CellItem = true" (default).  Notice single 'a' section and multiple 'item' sections</b></p><pre class="codeinput">Pref=[]; Pref.CellItem = true;
xml_write(<span class="string">'test.xml'</span>, MyTree, <span class="string">'MyTree'</span>,Pref);
type(<span class="string">'test.xml'</span>)
fprintf(<span class="string">'\nxml_read output:\n'</span>);
disp(xml_read (<span class="string">'test.xml'</span>))
</pre><pre class="codeoutput">
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;MyTree&gt;
   &lt;a&gt;
      &lt;item&gt;jack&lt;/item&gt;
      &lt;item&gt;john&lt;/item&gt;
   &lt;/a&gt;
&lt;/MyTree&gt;

xml_read output:
    a: {'jack'  'john'}
</pre><p><b>Write XML with "CellItem = false". Notice multiple 'a' sections</b></p><pre class="codeinput">Pref=[]; Pref.CellItem = false;
xml_write(<span class="string">'test.xml'</span>, MyTree, <span class="string">'MyTree'</span>,Pref);
type(<span class="string">'test.xml'</span>)
fprintf(<span class="string">'\nxml_read output:\n'</span>);
disp(xml_read (<span class="string">'test.xml'</span>))
</pre><pre class="codeoutput">
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;MyTree&gt;
   &lt;a&gt;jack&lt;/a&gt;
   &lt;a&gt;john&lt;/a&gt;
&lt;/MyTree&gt;

xml_read output:
    a: {'jack'  'john'}
</pre><p><b>Notice that xml_read function produced the same struct when reading both files</b></p>
         <h2>"Pref.NoCells" flag in "xml_read"<a name="20"></a></h2>
         <p><b>Create a cell/struct mixture object</b></p><pre class="codeinput">MyTree = [];
MyTree.a{1}.b = <span class="string">'jack'</span>;
MyTree.a{2}.b = [];
MyTree.a{2}.c = <span class="string">'john'</span>;
gen_object_display(MyTree);
</pre><pre class="codeoutput">    a: [1x2 cell] = 
       b: 'jack'

       b: [0x0 double]
       c: 'john'

</pre><p><b>Save it to xml file</b></p><pre class="codeinput">Pref=[]; Pref.CellItem = false;
xml_write(<span class="string">'test.xml'</span>, MyTree, <span class="string">'MyTree'</span>,Pref);
type(<span class="string">'test.xml'</span>)
</pre><pre class="codeoutput">
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;MyTree&gt;
   &lt;a&gt;
      &lt;b&gt;jack&lt;/b&gt;
   &lt;/a&gt;
   &lt;a&gt;
      &lt;b/&gt;
      &lt;c&gt;john&lt;/c&gt;
   &lt;/a&gt;
&lt;/MyTree&gt;
</pre><p><b>Read above file with "Pref.NoCells=true" (default) - output is quite different then input</b> By default program is trying to convert everything to struct's and arrays of structs. In case arrays of structs all the structs
            in array need to have the same fields, and if they are not than MATLAB creates empty fields.
         </p><pre class="codeinput">Pref=[]; Pref.NoCells=true;
gen_object_display(xml_read(<span class="string">'test.xml'</span>, Pref))
</pre><pre class="codeoutput">    a: [2x1 struct]
       b: 'jack'
       c: [0x0 double]

       b: [0x0 double]
       c: 'john'

</pre><p><b>Read above file with "Pref.NoCells=false" - now input and output are the same</b> Cell arrays of structs allow structs in array to have different fields.
         </p><pre class="codeinput">Pref=[]; Pref.NoCells=false;
gen_object_display(xml_read(<span class="string">'test.xml'</span>, Pref))
</pre><pre class="codeoutput">    a: [1x2 cell] = 
       b: 'jack'

       b: [0x0 double]
       c: 'john'

</pre><h2>"Pref.ItemName" flag in "xml_write"<a name="24"></a></h2>
         <p><b>Create a cell/struct mixture object</b></p><pre class="codeinput">MyTree = [];
MyTree.a{1}.b = <span class="string">'jack'</span>;
MyTree.a{2}.c = <span class="string">'john'</span>;
gen_object_display(MyTree);
</pre><pre class="codeoutput">    a: [1x2 cell] = 
       b: 'jack'

       c: 'john'

</pre><p><b>Save it to xml file, using 'item' notation but with different name</b></p><pre class="codeinput">Pref=[];
Pref.CellItem = true;
Pref.ItemName = <span class="string">'MyItem'</span>;
xml_write(<span class="string">'test.xml'</span>, MyTree, <span class="string">'MyTree'</span>,Pref);
type(<span class="string">'test.xml'</span>)
</pre><pre class="codeoutput">
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;MyTree&gt;
   &lt;a&gt;
      &lt;MyItem&gt;
         &lt;b&gt;jack&lt;/b&gt;
      &lt;/MyItem&gt;
      &lt;MyItem&gt;
         &lt;c&gt;john&lt;/c&gt;
      &lt;/MyItem&gt;
   &lt;/a&gt;
&lt;/MyTree&gt;
</pre><h2>"Pref.ItemName" flag in "xml_read"<a name="26"></a></h2>
         <p><b>Read above file with default settings ("Pref.ItemName = 'item'")</b> The results do not match the original structure
         </p><pre class="codeinput">Pref=[]; Pref.NoCells  = false;
gen_object_display(xml_read(<span class="string">'test.xml'</span>, Pref))
</pre><pre class="codeoutput">    a: [1x1 struct]
       MyItem: [1x2 cell] = 
               b: 'jack'

               c: 'john'

</pre><p><b>Read above file with "Pref.ItemName = 'MyItem'" - now saved and read MATLAB structures are the same</b></p><pre class="codeinput">Pref=[];
Pref.ItemName = <span class="string">'MyItem'</span>;
Pref.NoCells  = false;
gen_object_display(xml_read(<span class="string">'test.xml'</span>, Pref))
</pre><pre class="codeoutput">    a: [1x2 cell] = 
       b: 'jack'

       c: 'john'

</pre><h2>"Pref.CellItem" flag in "xml_read"<a name="28"></a></h2>
         <p>"Pref.ItemName" is used to create xml files with clearly marked arrays "Pref.CellItem" flag in "xml_read" ensures that they
            are always read as arrays by forcing output to stay in cell format. In cell format s{1} is different than s, while s(1) is
            indistinguishable from s.
         </p>
         <p><b>Create a test file</b></p><pre class="codeinput">MyTree = [];
MyTree.a1{1}.b = <span class="string">'jack'</span>; <span class="comment">% a1 - single struct</span>
MyTree.a2{1}.b = <span class="string">'jack'</span>; <span class="comment">% a2 - cell array of structs with the same fields</span>
MyTree.a2{2}.b = <span class="string">'john'</span>;
MyTree.a3{1}.b = <span class="string">'jack'</span>; <span class="comment">% a3 - cell array of structs with the different fields</span>
MyTree.a3{2}.c = <span class="string">'john'</span>;
Pref=[];
Pref.CellItem = true;
Pref.Debug = true;
xml_write(<span class="string">'test.xml'</span>, MyTree, <span class="string">'MyTree'</span>,Pref);
type(<span class="string">'test.xml'</span>)
</pre><pre class="codeoutput">
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;MyTree&gt;
   &lt;a1&gt;
      &lt;item&gt;
         &lt;b&gt;jack&lt;/b&gt;
      &lt;/item&gt;
   &lt;/a1&gt;
   &lt;a2&gt;
      &lt;item&gt;
         &lt;b&gt;jack&lt;/b&gt;
      &lt;/item&gt;
      &lt;item&gt;
         &lt;b&gt;john&lt;/b&gt;
      &lt;/item&gt;
   &lt;/a2&gt;
   &lt;a3&gt;
      &lt;item&gt;
         &lt;b&gt;jack&lt;/b&gt;
      &lt;/item&gt;
      &lt;item&gt;
         &lt;c&gt;john&lt;/c&gt;
      &lt;/item&gt;
   &lt;/a3&gt;
&lt;/MyTree&gt;
</pre><p><b>Read above file with "Pref.CellItem = true" (default)</b> All outputs are in cell format
         </p><pre class="codeinput">Pref=[];
Pref.NoCells  = false;  <span class="comment">% allow cell output</span>
Pref.CellItem = true;   <span class="comment">% keep 'item' arrays as cells</span>
gen_object_display(xml_read(<span class="string">'test.xml'</span>, Pref))
</pre><pre class="codeoutput">    a1: [1x1 cell] = 
        b: 'jack'

    a2: [1x1 cell] = 
            [1x1 struct]    [1x1 struct]

    a3: [1x1 cell] = 
            [1x1 struct]    [1x1 struct]

</pre><p><b>Read above file with "Pref.CellItem = false"</b> Outputs format is determined by content
         </p><pre class="codeinput">Pref=[];
Pref.NoCells  = false; <span class="comment">% allow cell output</span>
Pref.CellItem = false; <span class="comment">% allow 'item' arrays to beheave like other fields</span>
gen_object_display(xml_read(<span class="string">'test.xml'</span>, Pref))
</pre><pre class="codeoutput">    a1: [1x1 struct]
        b: 'jack'
    a2: [2x1 struct]
        b: 'jack'

        b: 'john'

    a3: [1x2 cell] = 
        b: 'jack'

        c: 'john'

</pre><p><b>Read above file with "Pref.CellItem = false" and "Pref.NoCells  = true"</b> All outputs are in struct format
         </p><pre class="codeinput">Pref=[];
Pref.NoCells  = true;  <span class="comment">% don't allow cell output</span>
Pref.CellItem = false; <span class="comment">% allow 'item' arrays to beheave like other fields</span>
gen_object_display(xml_read(<span class="string">'test.xml'</span>, Pref))
</pre><pre class="codeoutput">    a1: [1x1 struct]
        b: 'jack'
    a2: [2x1 struct]
        b: 'jack'

        b: 'john'

    a3: [2x1 struct]
        b: 'jack'
        c: [0x0 double]

        b: [0x0 double]
        c: 'john'

</pre><h2>"Pref.Str2Num" flag in xml_read<a name="33"></a></h2>
         <p><b>Create a cell/struct mixture object</b></p><pre class="codeinput">MyTree = [];
MyTree.str     = <span class="string">'sphere'</span>;
MyTree.num1    =  123;
MyTree.num2    = <span class="string">'123'</span>;
MyTree.num3    = <span class="string">'[Inf,NaN]'</span>;
MyTree.calc    = <span class="string">'1+2+3+4'</span>;
MyTree.func    = <span class="string">'sin(pi)/2'</span>;
MyTree.String1 = <span class="string">'[2003 10 30]'</span>;
MyTree.String2 = <span class="string">'2003 10 30'</span>;   <span class="comment">% array resembling date</span>
MyTree.ISO8601 = <span class="string">'2003-10-30'</span>;   <span class="comment">% date in ISO 8601 format</span>
MyTree.US_date = <span class="string">'2003/10/30'</span>;   <span class="comment">% US style date format</span>
MyTree.complex = <span class="string">'2003i-10e-30'</span>; <span class="comment">% complex number resembling a date</span>
gen_object_display(MyTree);
</pre><pre class="codeoutput">        str: 'sphere'
       num1: [123]
       num2: '123'
       num3: '[Inf,NaN]'
       calc: '1+2+3+4'
       func: 'sin(pi)/2'
    String1: '[2003 10 30]'
    String2: '2003 10 30'
    ISO8601: '2003-10-30'
    US_date: '2003/10/30'
    complex: '2003i-10e-30'
</pre><p><b>Save it to xml file</b></p><pre class="codeinput">xml_write(<span class="string">'test.xml'</span>, MyTree);
type(<span class="string">'test.xml'</span>)
</pre><pre class="codeoutput">
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;MyTree&gt;
   &lt;str&gt;sphere&lt;/str&gt;
   &lt;num1&gt;123&lt;/num1&gt;
   &lt;num2&gt;123&lt;/num2&gt;
   &lt;num3&gt;[Inf,NaN]&lt;/num3&gt;
   &lt;calc&gt;1+2+3+4&lt;/calc&gt;
   &lt;func&gt;sin(pi)/2&lt;/func&gt;
   &lt;String1&gt;[2003 10 30]&lt;/String1&gt;
   &lt;String2&gt;2003 10 30&lt;/String2&gt;
   &lt;ISO8601&gt;2003-10-30&lt;/ISO8601&gt;
   &lt;US_date&gt;2003/10/30&lt;/US_date&gt;
   &lt;complex&gt;2003i-10e-30&lt;/complex&gt;
&lt;/MyTree&gt;
</pre><p><b>Read above file with default settings</b> ("Pref.Str2Num = true" or "Pref.Str2Num = 'smart'"). Under this setting all strings that look like numbers are converted
            to numbers, except for strings that are recognized by MATLAB 'datenum' function as dates
         </p><pre class="codeinput">gen_object_display(xml_read(<span class="string">'test.xml'</span>))
</pre><pre class="codeoutput">        str: 'sphere'
       num1: [123]
       num2: [123]
       num3: [Inf  NaN]
       calc: [10]
       func: 'sin(pi)/2'
    String1: [2003    10    30]
    String2: [2003    10    30]
    ISO8601: '2003-10-30'
    US_date: '2003/10/30'
    complex: [-1e-029+2003i]
</pre><p><b>Note that all the fields of 'MyTree' can be converted to numbers (even 'sphere') but by default the function is trying to
               'judge' if a string should be converted to a number or not</b></p><pre class="codeinput">MyCell = {<span class="string">'sphere'</span>,<span class="string">'1+2+3+4'</span>,<span class="string">'sin(pi)/2'</span>,<span class="string">'2003 10 30'</span>,<span class="string">'2003-10-30'</span>,<span class="string">'2003/10/30'</span>,<span class="string">'2003i-10e-30'</span>};
cellfun(@str2num, MyCell, <span class="string">'UniformOutput'</span>, false)
</pre><pre class="codeoutput">ans = 
  Columns 1 through 6
    [21x21 double]    [10]    [6.1232e-017]    [1x3 double]    [1963]    [6.6767]
  Column 7
    [-1.0000e-029 +2.0030e+003i]
</pre><p><b>Read above file with "Pref.Str2Num = false" or "Pref.Str2Num = 'never'" to keep all the fields in string format</b></p><pre class="codeinput">Pref=[]; Pref.Str2Num = false;
gen_object_display(xml_read(<span class="string">'test.xml'</span>, Pref))
</pre><pre class="codeoutput">        str: 'sphere'
       num1: '123'
       num2: '123'
       num3: '[Inf,NaN]'
       calc: '1+2+3+4'
       func: 'sin(pi)/2'
    String1: '[2003 10 30]'
    String2: '2003 10 30'
    ISO8601: '2003-10-30'
    US_date: '2003/10/30'
    complex: '2003i-10e-30'
</pre><p><b>Read above file with "Pref.Str2Num = always" to convert all strings that look like numbers to numbers</b> note the likelly unintendet conversion of 'ISO8601'
         </p><pre class="codeinput">Pref=[]; Pref.Str2Num   = <span class="string">'always'</span>;
gen_object_display(xml_read(<span class="string">'test.xml'</span>, Pref))
</pre><pre class="codeoutput">        str: 'sphere'
       num1: [123]
       num2: [123]
       num3: [Inf  NaN]
       calc: [10]
       func: 'sin(pi)/2'
    String1: [2003    10    30]
    String2: [2003    10    30]
    ISO8601: [1963]
    US_date: '2003/10/30'
    complex: [-1e-029+2003i]
</pre><p><b>Notice that all three settings will produce the same output for "num1" and "num2" and there is no way to reproduce the original
               "MyTree" structure.</b></p>
         <h2>"Pref.PreserveSpace" flag in xml_write<a name="40"></a></h2>
         <p><b>Create a struct with strings</b></p><pre class="codeinput">MyTree=[];
MyTree.Empty     = <span class="string">''</span>;
MyTree.OneSpace  = <span class="string">' '</span>;
MyTree.TwoSpaces = <span class="string">'  '</span>;
MyTree.String1   = <span class="string">' Hello      World '</span>;
</pre><p><b>Write XML with "PreserveSpace = false" (default).</b></p><pre class="codeinput">Pref=[]; Pref.PreserveSpace = false; <span class="comment">% (default setting)</span>
xml_write(<span class="string">'test.xml'</span>, MyTree, [], Pref);
type(<span class="string">'test.xml'</span>)
</pre><pre class="codeoutput">
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;MyTree&gt;
   &lt;Empty/&gt;
   &lt;OneSpace/&gt;
   &lt;TwoSpaces/&gt;
   &lt;String1&gt;Hello World&lt;/String1&gt;
&lt;/MyTree&gt;
</pre><p><b>Write XML with "PreserveSpace = true".</b></p><pre class="codeinput">Pref=[]; Pref.PreserveSpace = true;
xml_write(<span class="string">'test.xml'</span>, MyTree, [], Pref);
type(<span class="string">'test.xml'</span>)
</pre><pre class="codeoutput">
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;MyTree&gt;
   &lt;Empty/&gt;
   &lt;OneSpace&gt; &lt;/OneSpace&gt;
   &lt;TwoSpaces&gt;  &lt;/TwoSpaces&gt;
   &lt;String1&gt; Hello      World &lt;/String1&gt;
&lt;/MyTree&gt;
</pre><h2>"Pref.PreserveSpace" flag in xml_read<a name="43"></a></h2>
         <p><b>Read file while using "PreserveSpace = false" (default).</b></p><pre class="codeinput">Pref=[]; Pref.PreserveSpace = false; <span class="comment">% (default setting)</span>
gen_object_display(xml_read(<span class="string">'test.xml'</span>,Pref))
</pre><pre class="codeoutput">        Empty: [0x0 double]
     OneSpace: [0x0 double]
    TwoSpaces: [0x0 double]
      String1: 'Hello      World'
</pre><p><b>Read file while using "PreserveSpace = true".</b></p><pre class="codeinput">Pref=[]; Pref.PreserveSpace = true;
gen_object_display(xml_read(<span class="string">'test.xml'</span>,Pref))
</pre><pre class="codeoutput">        Empty: [0x0 double]
     OneSpace: ' '
    TwoSpaces: '  '
      String1: ' Hello      World '
</pre><h2>Write XML files with ATTRIBUTEs<a name="45"></a></h2>
         <p>In order to add node attributes a special ATTRIBUTE field is used. ATTRIBUTEs have to be of simple types like numbers or strings
            (not struct or cells). Attributes are easy to attach to structs nodes like MyTree below.
         </p><pre class="codeinput">MyTree=[];
MyTree.MyNumber = 13;
MyTree.MyString = <span class="string">'Hello World'</span>; <span class="comment">% simple case</span>
MyTree.ATTRIBUTE.Num = 2;
xml_write(<span class="string">'test.xml'</span>, MyTree);
type(<span class="string">'test.xml'</span>)
</pre><pre class="codeoutput">
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;MyTree Num="2"&gt;
   &lt;MyNumber&gt;13&lt;/MyNumber&gt;
   &lt;MyString&gt;Hello World&lt;/MyString&gt;
&lt;/MyTree&gt;
</pre><p>In case when one needs to attach attributes to nodes which are not structs (for example strings, numbers or calls) then special
            CONTENT field needs to be used to make the node a struct node.
         </p><pre class="codeinput">MyTree=[];
MyTree.MyNumber = 13;
MyTree.MyString.CONTENT = <span class="string">'Hello World'</span>; <span class="comment">% simple case</span>
MyTree.MyString.ATTRIBUTE.Num = 2;
xml_write(<span class="string">'test.xml'</span>, MyTree);
type(<span class="string">'test.xml'</span>)
</pre><pre class="codeoutput">
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;MyTree&gt;
   &lt;MyNumber&gt;13&lt;/MyNumber&gt;
   &lt;MyString Num="2"&gt;Hello World&lt;/MyString&gt;
&lt;/MyTree&gt;
</pre><h2>"Pref.Str2Num" flag in file with ATTRIBUTEs<a name="47"></a></h2>
         <p><b>Create a cell/struct mixture object</b></p><pre class="codeinput">MyTree = [];
MyTree.X.ATTRIBUTE.str     = <span class="string">'sphere'</span>;
MyTree.X.ATTRIBUTE.num1    =  123;
MyTree.X.ATTRIBUTE.num2    = <span class="string">'123'</span>;
MyTree.X.ATTRIBUTE.num3    = <span class="string">'[Inf,NaN]'</span>;
MyTree.X.ATTRIBUTE.calc    = <span class="string">'1+2+3+4'</span>;
MyTree.X.ATTRIBUTE.func    = <span class="string">'sin(pi)/2'</span>;
MyTree.X.ATTRIBUTE.String1 = <span class="string">'[2003 10 30]'</span>;
MyTree.X.ATTRIBUTE.String2 = <span class="string">'2003 10 30'</span>;   <span class="comment">% array resembling date</span>
MyTree.X.ATTRIBUTE.ISO8601 = <span class="string">'2003-10-30'</span>;   <span class="comment">% date in ISO 8601 format</span>
MyTree.X.ATTRIBUTE.US_date = <span class="string">'2003/10/30'</span>;   <span class="comment">% US style date format</span>
MyTree.X.ATTRIBUTE.complex = <span class="string">'2003i-10e-30'</span>; <span class="comment">% complex number resembling a date</span>
gen_object_display(MyTree);
</pre><pre class="codeoutput">    X: [1x1 struct]
       ATTRIBUTE: [1x1 struct]
                      str: 'sphere'
                     num1: [123]
                     num2: '123'
                     num3: '[Inf,NaN]'
                     calc: '1+2+3+4'
                     func: 'sin(pi)/2'
                  String1: '[2003 10 30]'
                  String2: '2003 10 30'
                  ISO8601: '2003-10-30'
                  US_date: '2003/10/30'
                  complex: '2003i-10e-30'
</pre><p><b>Save it to xml file</b></p><pre class="codeinput">xml_write(<span class="string">'test.xml'</span>, MyTree);
type(<span class="string">'test.xml'</span>)
</pre><pre class="codeoutput">
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;MyTree&gt;
   &lt;X ISO8601="2003-10-30" String1="[2003 10 30]" String2="2003 10 30" US_date="2003/10/30" calc="1+2+3+4" complex="2003i-10e-30" func="sin(pi)/2" num1="123" num2="123" num3="[Inf,NaN]" str="sphere"/&gt;
&lt;/MyTree&gt;
</pre><p><b>Read above file with default settings</b> ("Pref.Str2Num = true" or "Pref.Str2Num = 'smart'"). Under this setting all strings that look like numbers are converted
            to numbers, except for strings that are recognized by MATLAB 'datenum' function as dates
         </p><pre class="codeinput">gen_object_display(xml_read(<span class="string">'test.xml'</span>))
</pre><pre class="codeoutput">    X: [1x1 struct]
         CONTENT: [0x0 double]
       ATTRIBUTE: [1x1 struct]
                  ISO8601: '2003-10-30'
                  String1: '[2003 10 30]'
                  String2: '2003 10 30'
                  US_date: '2003/10/30'
                     calc: '1+2+3+4'
                  complex: [-1e-029+2003i]
                     func: 'sin(pi)/2'
                     num1: [123]
                     num2: [123]
                     num3: '[Inf,NaN]'
                      str: 'sphere'
</pre><p><b>Read above file with "Pref.Str2Num = false" or "Pref.Str2Num = 'never'" to keep all the fields in string format</b></p><pre class="codeinput">Pref=[]; Pref.Str2Num = false;
gen_object_display(xml_read(<span class="string">'test.xml'</span>, Pref))
</pre><pre class="codeoutput">    X: [1x1 struct]
         CONTENT: [0x0 double]
       ATTRIBUTE: [1x1 struct]
                  ISO8601: '2003-10-30'
                  String1: '[2003 10 30]'
                  String2: '2003 10 30'
                  US_date: '2003/10/30'
                     calc: '1+2+3+4'
                  complex: '2003i-10e-30'
                     func: 'sin(pi)/2'
                     num1: '123'
                     num2: '123'
                     num3: '[Inf,NaN]'
                      str: 'sphere'
</pre><p><b>Read above file with "Pref.Str2Num = always" to convert all strings that look like numbers to numbers</b></p><pre class="codeinput">Pref=[]; Pref.Str2Num   = <span class="string">'always'</span>;
gen_object_display(xml_read(<span class="string">'test.xml'</span>, Pref))
</pre><pre class="codeoutput">    X: [1x1 struct]
         CONTENT: [0x0 double]
       ATTRIBUTE: [1x1 struct]
                  ISO8601: '2003-10-30'
                  String1: '[2003 10 30]'
                  String2: '2003 10 30'
                  US_date: '2003/10/30'
                     calc: '1+2+3+4'
                  complex: [-1e-029+2003i]
                     func: 'sin(pi)/2'
                     num1: [123]
                     num2: [123]
                     num3: '[Inf,NaN]'
                      str: 'sphere'
</pre><p><b>Notice that all three settings will produce the same output for "num1" and "num2" and there is no way to reproduce the original
               "MyTree" structure.</b></p>
         <h2>Write XML files with COMMENTs<a name="53"></a></h2>
         <p>Insertion of Comments is done with help of special COMMENT field. Note that MATLAB's xmlwrite is less readable due to lack
            of end-of-line characters around comment section.
         </p><pre class="codeinput">MyTree=[];
MyTree.COMMENT = <span class="string">'This is a comment'</span>;
MyTree.MyNumber = 13;
MyTree.MyString.CONTENT = <span class="string">'Hello World'</span>;
xml_write(<span class="string">'test.xml'</span>, MyTree);
type(<span class="string">'test.xml'</span>)
</pre><pre class="codeoutput">
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;MyTree&gt;&lt;!--This is a comment--&gt;
   &lt;MyNumber&gt;13&lt;/MyNumber&gt;
   &lt;MyString&gt;Hello World&lt;/MyString&gt;
&lt;/MyTree&gt;
</pre><p><b>Same operation using Apache Xerces XML engine</b> gives the same result
         </p><pre class="codeinput">Pref=[]; Pref.XmlEngine = <span class="string">'Xerces'</span>;  <span class="comment">% use Xerces xml generator directly</span>
xml_write(<span class="string">'test.xml'</span>, MyTree, <span class="string">'MyTree'</span>, Pref);
type(<span class="string">'test.xml'</span>)
</pre><pre class="codeoutput">
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;MyTree&gt;
    &lt;!--This is a comment--&gt;
    &lt;MyNumber&gt;13&lt;/MyNumber&gt;
    &lt;MyString&gt;Hello World&lt;/MyString&gt;
&lt;/MyTree&gt;

</pre><p><b>Comments in XML top level (method #1)</b> This method uses cell array
         </p><pre class="codeinput">MyTree=[];
MyTree.MyNumber = 13;
MyTree.MyString = <span class="string">'Hello World'</span>;
xml_write(<span class="string">'test.xml'</span>, MyTree, {<span class="string">'MyTree'</span>, [], <span class="string">'This is a global comment'</span>});
type(<span class="string">'test.xml'</span>)
</pre><pre class="codeoutput">
&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;!--This is a global comment--&gt;
&lt;MyTree&gt;
   &lt;MyNumber&gt;13&lt;/MyNumber&gt;
   &lt;MyString&gt;Hello World&lt;/MyString&gt;
&lt;/MyTree&gt;
</pre><p><b>Same operation using Apache Xerces XML engine</b> gives even nicer results.
         </p><pre class="codeinput">Pref=[]; Pref.XmlEngine = <span class="string">'Xerces'</span>;  <span class="comment">% use Xerces xml generator directly</span>
xml_write(<span class="string">'test.xml'</span>, MyTree, {<span class="string">'MyTree'</span>, [], <span class="string">'This is a global comment'</span>}, Pref);
type(<span class="string">'test.xml'</span>)
</pre><pre class="codeoutput">
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!--This is a global comment--&gt;
&lt;MyTree&gt;
    &lt;MyNumber&gt;13&lt;/MyNumber&gt;
    &lt;MyString&gt;Hello World&lt;/MyString&gt;
&lt;/MyTree&gt;

</pre><p><b>Comments in XML top level (method #2)</b> This method adds an extra top layer to the struct 'tree' and sets "Pref.RootOnly = false", which informs the function about
            the extra layer. Notice that RootName is also saved as a part of the 'tree', and does not have to be passed in separately.
         </p><pre class="codeinput">MyTree=[];
MyTree.COMMENT = <span class="string">'This is a global comment'</span>;
MyTree.MyTest.MyNumber = 13;
MyTree.MyTest.MyString = <span class="string">'Hello World'</span>;
Pref=[]; Pref.RootOnly = false;
xml_write(<span class="string">'test.xml'</span>, MyTree, [], Pref);
type(<span class="string">'test.xml'</span>)
</pre><pre class="codeoutput">
&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;!--This is a global comment--&gt;
&lt;MyTest&gt;
   &lt;MyNumber&gt;13&lt;/MyNumber&gt;
   &lt;MyString&gt;Hello World&lt;/MyString&gt;
&lt;/MyTest&gt;
</pre><p><b>Same operation using Apache Xerces XML engine</b></p><pre class="codeinput">Pref=[]; Pref.XmlEngine = <span class="string">'Xerces'</span>;  <span class="comment">% use Xerces xml generator directly</span>
Pref.RootOnly  = false;
xml_write(<span class="string">'test.xml'</span>, MyTree, [], Pref);
type(<span class="string">'test.xml'</span>)
</pre><pre class="codeoutput">
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!--This is a global comment--&gt;
&lt;MyTest&gt;
    &lt;MyNumber&gt;13&lt;/MyNumber&gt;
    &lt;MyString&gt;Hello World&lt;/MyString&gt;
&lt;/MyTest&gt;

</pre><h2>Write XML files with PROCESSING_INSTRUCTIONs<a name="59"></a></h2>
         <p>Insertion of Processing Instructions is done through use of special PROCESSING_INSTRUCTION field, which stores the instruction
            string. The string has to be in 'target data' format separated by space.
         </p><pre class="codeinput">MyTree=[];
MyTree.PROCESSING_INSTRUCTION = <span class="string">'xml-stylesheet type="a" href="foo"'</span>;
MyTree.MyNumber = 13;
MyTree.MyString = <span class="string">'Hello World'</span>;
xml_write(<span class="string">'test.xml'</span>, MyTree);
type(<span class="string">'test.xml'</span>)
</pre><pre class="codeoutput">
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;MyTree&gt;&lt;?xml-stylesheet type="a" href="foo"?&gt;
   &lt;MyNumber&gt;13&lt;/MyNumber&gt;
   &lt;MyString&gt;Hello World&lt;/MyString&gt;
&lt;/MyTree&gt;
</pre><p><b>Same operation using Apache Xerces XML engine</b></p><pre class="codeinput">Pref=[]; Pref.XmlEngine = <span class="string">'Xerces'</span>;  <span class="comment">% use Xerces xml generator directly</span>
xml_write(<span class="string">'test.xml'</span>, MyTree, <span class="string">'MyTree'</span>, Pref);
type(<span class="string">'test.xml'</span>)
</pre><pre class="codeoutput">
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;MyTree&gt;&lt;?xml-stylesheet type="a" href="foo"?&gt;
    &lt;MyNumber&gt;13&lt;/MyNumber&gt;
    &lt;MyString&gt;Hello World&lt;/MyString&gt;
&lt;/MyTree&gt;

</pre><p><b>PROCESSING_INSTRUCTIONs in XML top level (method #1)</b> This method uses cell array
         </p><pre class="codeinput">MyTree=[];
MyTree.MyNumber = 13;
MyTree.MyString = <span class="string">'Hello World'</span>;
xml_write(<span class="string">'test.xml'</span>, MyTree, {<span class="string">'MyTree'</span>, <span class="string">'xml-stylesheet type="a" href="foo"'</span>});
type(<span class="string">'test.xml'</span>)
</pre><pre class="codeoutput">
&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;?xml-stylesheet type="a" href="foo"?&gt;
&lt;MyTree&gt;
   &lt;MyNumber&gt;13&lt;/MyNumber&gt;
   &lt;MyString&gt;Hello World&lt;/MyString&gt;
&lt;/MyTree&gt;
</pre><p><b>Same operation using Apache Xerces XML engine</b></p><pre class="codeinput">Pref=[]; Pref.XmlEngine = <span class="string">'Xerces'</span>;  <span class="comment">% use Xerces xml generator directly</span>
xml_write(<span class="string">'test.xml'</span>, MyTree, {<span class="string">'MyTree'</span>, <span class="string">'xml-stylesheet type="a" href="foo"'</span>}, Pref);
type(<span class="string">'test.xml'</span>)
</pre><pre class="codeoutput">
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;?xml-stylesheet type="a" href="foo"?&gt;
&lt;MyTree&gt;
    &lt;MyNumber&gt;13&lt;/MyNumber&gt;
    &lt;MyString&gt;Hello World&lt;/MyString&gt;
&lt;/MyTree&gt;

</pre><p><b>PROCESSING_INSTRUCTIONs in XML top level (method #2)</b> This method adds an extra top layer to the struct 'tree' and sets pref.RootOnly=false, which informs the function about the
            extra layer. Notice that RootName is also saved as a part of the 'tree', and does not have to be passed in separately.
         </p><pre class="codeinput">MyTree=[];
MyTree.PROCESSING_INSTRUCTION =  <span class="string">'xml-stylesheet type="a" href="foo"'</span>;
MyTree.MyTest.MyNumber = 13;
MyTree.MyTest.MyString = <span class="string">'Hello World'</span>;
Pref=[]; Pref.RootOnly = false;
xml_write(<span class="string">'test.xml'</span>, MyTree, [], Pref);
type(<span class="string">'test.xml'</span>)
</pre><pre class="codeoutput">
&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;?xml-stylesheet type="a" href="foo"?&gt;
&lt;MyTest&gt;
   &lt;MyNumber&gt;13&lt;/MyNumber&gt;
   &lt;MyString&gt;Hello World&lt;/MyString&gt;
&lt;/MyTest&gt;
</pre><p><b>Same operation using Apache Xerces XML engine</b></p><pre class="codeinput">Pref=[]; Pref.XmlEngine = <span class="string">'Xerces'</span>;  <span class="comment">% use Xerces xml generator directly</span>
Pref.RootOnly  = false;
xml_write(<span class="string">'test.xml'</span>, MyTree, <span class="string">'MyTree'</span>, Pref);
type(<span class="string">'test.xml'</span>)
</pre><pre class="codeoutput">
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;?xml-stylesheet type="a" href="foo"?&gt;
&lt;MyTest&gt;
    &lt;MyNumber&gt;13&lt;/MyNumber&gt;
    &lt;MyString&gt;Hello World&lt;/MyString&gt;
&lt;/MyTest&gt;

</pre><h2>Write XML files with CDATA Sections<a name="65"></a></h2>
         <p>"In an XML document a CDATA (Character DATA) section is a section of  element content that is marked for the parser to interpret
            as only  character data, not markup." (from Wikipedia) To insert CDATA Sections one use special CDATA_SECTION field,  which
            stores the instruction string. Note that MATLAB's xmlwrite created  wrong xml code for CDATA section
         </p><pre class="codeinput">MyTree=[];
MyTree.CDATA_SECTION = <span class="string">'&lt;A&gt;txt&lt;/A&gt;'</span>;
MyTree.MyNumber = 13;
MyTree.MyString = <span class="string">'Hello World'</span>;
xml_write(<span class="string">'test.xml'</span>, MyTree);
type(<span class="string">'test.xml'</span>)
</pre><pre class="codeoutput">
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;MyTree&gt;&amp;lt;A&amp;gt;txt&amp;lt;/A&amp;gt;&lt;MyNumber&gt;13&lt;/MyNumber&gt;
   &lt;MyString&gt;Hello World&lt;/MyString&gt;
&lt;/MyTree&gt;
</pre><p><b>Same operation using Apache Xerces XML engine produces correct results</b></p><pre class="codeinput">Pref=[]; Pref.XmlEngine = <span class="string">'Xerces'</span>;  <span class="comment">% use Xerces xml generator directly</span>
xml_write(<span class="string">'test.xml'</span>, MyTree, <span class="string">'MyTree'</span>, Pref);
type(<span class="string">'test.xml'</span>)
</pre><pre class="codeoutput">
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;MyTree&gt;&lt;![CDATA[&lt;A&gt;txt&lt;/A&gt;]]&gt;&lt;MyNumber&gt;13&lt;/MyNumber&gt;
    &lt;MyString&gt;Hello World&lt;/MyString&gt;
&lt;/MyTree&gt;

</pre><h2>Write XML files with special characters in TAG names<a name="67"></a></h2>
         <p>The input to xml_write requires that all tags one wants in XML document have to be encoded as field names of MATLAB's struct's.
            Matlab has a lot of restrictions on variable names. This section is about XML tags with names not allowed as MATLAB variables,
            or more specifically with characters allowed as xml tag names but not allowed as MATLAB variable names. Characters like that
            can be replaced by their hexadecimal representation just as it is done by genvarname function. Alternative way of writing
            the first example is:
         </p><pre class="codeinput">MyTree=[];
MyTree.(<span class="string">'MyNumber'</span>) = 13;               <span class="comment">% same as MyTree.MyNumber = 13;</span>
MyTree.MyString.CONTENT = <span class="string">'Hello World'</span>;
MyTree.MyString.ATTRIBUTE.(<span class="string">'Num'</span>) = 2;  <span class="comment">% same as MyTree.MyString.ATTRIBUTE.Num = 2;</span>
xml_write(<span class="string">'test.xml'</span>, MyTree);
type(<span class="string">'test.xml'</span>)
</pre><pre class="codeoutput">
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;MyTree&gt;
   &lt;MyNumber&gt;13&lt;/MyNumber&gt;
   &lt;MyString Num="2"&gt;Hello World&lt;/MyString&gt;
&lt;/MyTree&gt;
</pre><p><b>This approach fails for some characters like dash '-', colon ':', and international characters.</b></p><pre class="codeinput">MyTree=[];
<span class="keyword">try</span>
  MyTree.(<span class="string">'My-Number'</span>) = 13;
  MyTree.MyString.CONTENT = <span class="string">'Hello World'</span>;
  MyTree.MyString.ATTRIBUTE.(<span class="string">'Num_&ouml;'</span>) = 2;
<span class="keyword">catch</span>  <span class="comment">%#ok&lt;CTCH&gt;</span>
  err = lasterror; <span class="comment">%#ok&lt;LERR&gt;</span>
  disp(err.message);
<span class="keyword">end</span>
</pre><pre class="codeoutput">Invalid field name: 'My-Number'.
</pre><p>It can be overcome by replacing offending characters with their hexadecimal representation. That can be done manually or with
            use of genvarname function. Note that MATLAB 'type' function does not show correctly '&ouml;' letter in xml file, but opening the
            file in editor shows that it is correct.
         </p><pre class="codeinput">MyTree=[];
MyTree.(genvarname(<span class="string">'My-Number'</span>)) = 13;
MyTree.MyString.CONTENT = <span class="string">'Hello World'</span>;
MyTree.MyString.ATTRIBUTE.Num_0xF6 = 2;
gen_object_display(MyTree);
xml_write(<span class="string">'test.xml'</span>, MyTree);
type(<span class="string">'test.xml'</span>)
</pre><pre class="codeoutput">    My0x2DNumber: [13]
        MyString: [1x1 struct]
                    CONTENT: 'Hello World'
                  ATTRIBUTE: [1x1 struct]
                             Num_0xF6: [2]

&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;MyTree&gt;
   &lt;My-Number&gt;13&lt;/My-Number&gt;
   &lt;MyString Num_&Atilde;&para;="2"&gt;Hello World&lt;/MyString&gt;
&lt;/MyTree&gt;
</pre><p><b>Also two of the characters '-' and ':' can be encoded by a special strings: '_DASH_' and '_COLON_' respectively</b></p><pre class="codeinput">MyTree=[];
MyTree.My_DASH_Number = 13;
MyTree.MyString.CONTENT = <span class="string">'Hello World'</span>;
MyTree.MyString.ATTRIBUTE.Num0xF6 = 2;
xml_write(<span class="string">'test.xml'</span>, MyTree);
type(<span class="string">'test.xml'</span>)
</pre><pre class="codeoutput">
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;MyTree&gt;
   &lt;My-Number&gt;13&lt;/My-Number&gt;
   &lt;MyString Num&Atilde;&para;="2"&gt;Hello World&lt;/MyString&gt;
&lt;/MyTree&gt;
</pre><h2>Write XML files with Namespaces<a name="71"></a></h2>
         <p>No extra special fields are needed to define XML namespaces, only colon character written using '0x3A' or '_COLON_'. Below
            is an example of a namespace definition
         </p><pre class="codeinput">MyTree=[];
MyTree.f_COLON_child.ATTRIBUTE.xmlns_COLON_f = <span class="string">'http://www.foo.com'</span>;
MyTree.f_COLON_child.f_COLON_MyNumber = 13;
MyTree.f_COLON_child.f_COLON_MyString = <span class="string">'Hello World'</span>;
xml_write(<span class="string">'test.xml'</span>, MyTree, <span class="string">'MyTree'</span>);
type(<span class="string">'test.xml'</span>)
</pre><pre class="codeoutput">
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;MyTree&gt;
   &lt;f:child xmlns:f="http://www.foo.com"&gt;
      &lt;f:MyNumber&gt;13&lt;/f:MyNumber&gt;
      &lt;f:MyString&gt;Hello World&lt;/f:MyString&gt;
   &lt;/f:child&gt;
&lt;/MyTree&gt;
</pre><p><b>Same operation using Apache Xerces XML engine</b></p><pre class="codeinput">Pref=[]; Pref.XmlEngine = <span class="string">'Xerces'</span>;  <span class="comment">% use Xerces xml generator directly</span>
xml_write(<span class="string">'test.xml'</span>, MyTree, <span class="string">'f_COLON_MyTree'</span>, Pref);
type(<span class="string">'test.xml'</span>)
</pre><pre class="codeoutput">
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;f:MyTree&gt;
    &lt;f:child xmlns:f="http://www.foo.com"&gt;
        &lt;f:MyNumber&gt;13&lt;/f:MyNumber&gt;
        &lt;f:MyString&gt;Hello World&lt;/f:MyString&gt;
    &lt;/f:child&gt;
&lt;/f:MyTree&gt;

</pre><h2>"Pref.KeepNS" flag in "xml_read"<a name="73"></a></h2>
         <p>Thise option allow keeping  or exclusion of namespaces in tag names. By default the namespace data is kept but it produces
            much longer field names in the output structure. Ignoring namespace will produce more readible output. Perform default read
            of file with namespace
         </p><pre class="codeinput">tree = xml_read(<span class="string">'test.xml'</span>);
gen_object_display(tree);
</pre><pre class="codeoutput">    f_COLON_child: [1x1 struct]
                   f_COLON_MyNumber: [13]
                   f_COLON_MyString: 'Hello World'
                          ATTRIBUTE: [1x1 struct]
                                     xmlns_COLON_f: 'http://www.foo.com'
</pre><p>Now the same operation with KeepNS = false.</p><pre class="codeinput">Pref=[]; Pref.KeepNS = false; <span class="comment">% do not read attributes</span>
tree = xml_read(<span class="string">'test.xml'</span>, Pref);
gen_object_display(tree);
</pre><pre class="codeoutput">    child: [1x1 struct]
            MyNumber: [13]
            MyString: 'Hello World'
           ATTRIBUTE: [1x1 struct]
                      f: 'http://www.foo.com'
</pre><h2>Read XML files with special node types<a name="75"></a></h2>
         <p>Display and read the file, then show the data structure. Note that MATLAB 'type' function shows '&ouml;' letter incorrectly as
            'A&para;' in xml file, but opening the file in editor shows that it is correct.
         </p><pre class="codeinput">fprintf(<span class="string">'Test xml file:\n'</span>);
type(<span class="string">'test_file.xml'</span>)
</pre><pre class="codeoutput">Test xml file:

&lt;?xml version="1.0" encoding="utf-8" ?&gt; 
&lt;?xml-stylesheet type="text/css" href="foo.css"?&gt;
&lt;!-- This is a Global Comment --&gt;
&lt;aaa xmlns:xsi="http://www.foo.org"&gt;
  &lt;?ProcInst type="local processing instruction"?&gt;
  &lt;!-- local comment 1 --&gt;
  bbb
  &lt;!-- local comment 2 --&gt;
  ccc
  &lt;matrix bad-name='fff'&gt;
    5e3+2*i, Inf
    NaN,     pi
  &lt;/matrix&gt;
  &lt;ee_e&gt; ee_e &lt;/ee_e&gt;
  &lt;ff-f&gt; ff-f &lt;/ff-f&gt;
  &lt;gg&Atilde;&para;g&gt; gg&Atilde;&para;g &lt;/gg&Atilde;&para;g&gt;
  &lt;![CDATA[
    Here &lt;ddd&gt;xml&lt;/ddd&gt; tags are treated as ...
    ... text
	]]&gt;
&lt;/aaa&gt;


</pre><p>Read only the Root Element (default)</p><pre class="codeinput">[tree GlobalTextNodes] = xml_read(<span class="string">'test_file.xml'</span>);
fprintf(<span class="string">'Global Data (Root name, Global Processing Instructions and Global Comments):\n'</span>);
disp(GlobalTextNodes')
fprintf(<span class="string">'\nStructure read from the file (uncludes COMMENT and CDATA sections):\n'</span>);
gen_object_display(tree);
</pre><pre class="codeoutput">Global Data (Root name, Global Processing Instructions and Global Comments):
    'aaa'
    'xml-stylesheet type="text/css" href="foo.css"'
    'This is a Global Comment'

Structure read from the file (uncludes COMMENT and CDATA sections):
    PROCESSING_INSTRUCTION: 'ProcInst type="local processing instruction"'
                   COMMENT: [1x2 cell] = 
                            local comment 1

                            local comment 2

                   CONTENT: [1x2 cell] = 
                            bbb

                            ccc

                    matrix: [1x1 struct]
                              CONTENT: [2x2 double]
                            ATTRIBUTE: [1x1 struct]
                                       bad_DASH_name: 'fff'
                      ee_e: 'ee_e'
                 ff_DASH_f: 'ff-f'
                   gg0xF6g: 'gg&ouml;g'
             CDATA_SECTION: 'Here &lt;ddd&gt;xml&lt;/ddd&gt; tags are treated as ...
    ... text'
                 ATTRIBUTE: [1x1 struct]
                            xmlns_COLON_xsi: 'http://www.foo.org'
</pre><p>Read the whole tree including global Comments and Processing Instructions</p><pre class="codeinput">Pref=[]; Pref.RootOnly = false;
[tree GlobalTextNodes] = xml_read(<span class="string">'test_file.xml'</span>, Pref);
fprintf(<span class="string">'Global Data (Root name, Global Processing Instructions and Global Comments):\n'</span>);
disp(GlobalTextNodes')
fprintf(<span class="string">'\nStructure read from the file (uncludes COMMENT and CDATA sections):\n'</span>);
gen_object_display(tree);
</pre><pre class="codeoutput">Global Data (Root name, Global Processing Instructions and Global Comments):
    'aaa'
    'xml-stylesheet type="text/css" href="foo.css"'
    'This is a Global Comment'

Structure read from the file (uncludes COMMENT and CDATA sections):
    PROCESSING_INSTRUCTION: 'xml-stylesheet type="text/css" href="foo.css"'
                   COMMENT: 'This is a Global Comment'
                       aaa: [1x1 struct]
                            PROCESSING_INSTRUCTION: 'ProcInst type="local processing instruction"'
                                           COMMENT: [1x2 cell] = 
                                                    local comment 1

                                                    local comment 2

                                           CONTENT: [1x2 cell] = 
                                                    bbb

                                                    ccc

                                            matrix: [1x1 struct]
                                                      CONTENT: [2x2 double]
                                                    ATTRIBUTE: [1x1 struct]
                                                               bad_DASH_name: 'fff'
                                              ee_e: 'ee_e'
                                         ff_DASH_f: 'ff-f'
                                           gg0xF6g: 'gg&ouml;g'
                                     CDATA_SECTION: 'Here &lt;ddd&gt;xml&lt;/ddd&gt; tags are treated as ...
    ... text'
                                         ATTRIBUTE: [1x1 struct]
                                                    xmlns_COLON_xsi: 'http://www.foo.org'
</pre><h2>"Pref.ReadAttr" flag in "xml_read"<a name="78"></a></h2>
         <p>Those option allow exclusion of attributes</p><pre class="codeinput">Pref=[]; Pref.ReadAttr = false; <span class="comment">% do not read attributes</span>
tree = xml_read(<span class="string">'test_file.xml'</span>, Pref);
gen_object_display(tree);
</pre><pre class="codeoutput">    PROCESSING_INSTRUCTION: 'ProcInst type="local processing instruction"'
                   COMMENT: [1x2 cell] = 
                            local comment 1

                            local comment 2

                   CONTENT: [1x2 cell] = 
                            bbb

                            ccc

                    matrix: [2x2 double]
                      ee_e: 'ee_e'
                 ff_DASH_f: 'ff-f'
                   gg0xF6g: 'gg&ouml;g'
             CDATA_SECTION: 'Here &lt;ddd&gt;xml&lt;/ddd&gt; tags are treated as ...
    ... text'
</pre><h2>"Pref.ReadSpec" flag in "xml_read"<a name="79"></a></h2>
         <p>Those option allow exclusion of special nodes, like comments, processing instructions, CData sections, etc.</p><pre class="codeinput">Pref=[]; Pref.ReadSpec = false; <span class="comment">% do not read special node types</span>
tree = xml_read(<span class="string">'test_file.xml'</span>, Pref);
gen_object_display(tree);
</pre><pre class="codeoutput">      CONTENT: [1x2 cell] = 
               bbb

               ccc

       matrix: [1x1 struct]
                 CONTENT: [2x2 double]
               ATTRIBUTE: [1x1 struct]
                          bad_DASH_name: 'fff'
         ee_e: 'ee_e'
    ff_DASH_f: 'ff-f'
      gg0xF6g: 'gg&ouml;g'
    ATTRIBUTE: [1x1 struct]
               xmlns_COLON_xsi: 'http://www.foo.org'
</pre><h2>"Pref.RootOnly" flag in "xml_read"<a name="80"></a></h2>
         <p>As it was shown in previous examples RootOnly parameter can be used to capture global (top level) special nodes (like COMMENTs
            and PROCESSING_INSTRUCTIONs) which are ignored by default
         </p><pre class="codeinput">Pref=[]; Pref.RootOnly = false; <span class="comment">% do not read special node types</span>
tree = xml_read(<span class="string">'test_file.xml'</span>, Pref);
gen_object_display(tree);
</pre><pre class="codeoutput">    PROCESSING_INSTRUCTION: 'xml-stylesheet type="text/css" href="foo.css"'
                   COMMENT: 'This is a Global Comment'
                       aaa: [1x1 struct]
                            PROCESSING_INSTRUCTION: 'ProcInst type="local processing instruction"'
                                           COMMENT: [1x2 cell] = 
                                                    local comment 1

                                                    local comment 2

                                           CONTENT: [1x2 cell] = 
                                                    bbb

                                                    ccc

                                            matrix: [1x1 struct]
                                                      CONTENT: [2x2 double]
                                                    ATTRIBUTE: [1x1 struct]
                                                               bad_DASH_name: 'fff'
                                              ee_e: 'ee_e'
                                         ff_DASH_f: 'ff-f'
                                           gg0xF6g: 'gg&ouml;g'
                                     CDATA_SECTION: 'Here &lt;ddd&gt;xml&lt;/ddd&gt; tags are treated as ...
    ... text'
                                         ATTRIBUTE: [1x1 struct]
                                                    xmlns_COLON_xsi: 'http://www.foo.org'
</pre><h2>"Pref.RootOnly" flag in "xml_write"<a name="81"></a></h2>
         <p>Writing previously read tree with default "Pref.RootOnly = true" gives wrong output file</p><pre class="codeinput">Pref=[]; Pref.RootOnly = true; <span class="comment">% do not read special node types</span>
xml_write(<span class="string">'test.xml'</span>, tree, [], Pref);
fprintf(<span class="string">'Test xml file:\n'</span>);
type(<span class="string">'test.xml'</span>)
</pre><pre class="codeoutput">Test xml file:

&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;tree&gt;&lt;?xml-stylesheet type="text/css" href="foo.css"?&gt;&lt;!--This is a Global Comment--&gt;
   &lt;aaa xmlns:xsi="http://www.foo.org"&gt;&lt;?ProcInst type="local processing instruction"?&gt;&lt;!--local comment 1--&gt;&lt;!--local comment 2--&gt;
      &lt;item&gt;bbb&lt;/item&gt;
      &lt;item&gt;ccc&lt;/item&gt;
      &lt;matrix bad-name="fff"&gt;[5000+i*2 Inf; NaN 3.14159265358979]&lt;/matrix&gt;
      &lt;ee_e&gt;ee_e&lt;/ee_e&gt;
      &lt;ff-f&gt;ff-f&lt;/ff-f&gt;
      &lt;gg&Atilde;&para;g&gt;gg&Atilde;&para;g&lt;/gg&Atilde;&para;g&gt;Here &amp;lt;ddd&amp;gt;xml&amp;lt;/ddd&amp;gt; tags are treated as ...
    ... text&lt;/aaa&gt;
&lt;/tree&gt;
</pre><p>Writing the same tree with "Pref.RootOnly = false" gives correct output</p><pre class="codeinput">Pref=[]; Pref.RootOnly = false; <span class="comment">% do not read special node types</span>
xml_write(<span class="string">'test.xml'</span>, tree, [], Pref);
fprintf(<span class="string">'Test xml file:\n'</span>);
type(<span class="string">'test.xml'</span>)
</pre><pre class="codeoutput">Test xml file:

&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;?xml-stylesheet type="text/css" href="foo.css"?&gt;&lt;!--This is a Global Comment--&gt;
&lt;aaa xmlns:xsi="http://www.foo.org"&gt;&lt;?ProcInst type="local processing instruction"?&gt;&lt;!--local comment 1--&gt;&lt;!--local comment 2--&gt;
   &lt;item&gt;bbb&lt;/item&gt;
   &lt;item&gt;ccc&lt;/item&gt;
   &lt;matrix bad-name="fff"&gt;[5000+i*2 Inf; NaN 3.14159265358979]&lt;/matrix&gt;
   &lt;ee_e&gt;ee_e&lt;/ee_e&gt;
   &lt;ff-f&gt;ff-f&lt;/ff-f&gt;
   &lt;gg&Atilde;&para;g&gt;gg&Atilde;&para;g&lt;/gg&Atilde;&para;g&gt;Here &amp;lt;ddd&amp;gt;xml&amp;lt;/ddd&amp;gt; tags are treated as ...
    ... text&lt;/aaa&gt;
</pre><h2>"Pref.NumLevels" flag in "xml_read"<a name="83"></a></h2>
         <p>This parameter allows user to skip parts of the tree in order to save time and memory. Usefull only in a rare case when a
            small portion of large XML file is needed.
         </p>
         <p>Create test tile</p><pre class="codeinput">MyTree = [];
MyTree.Level1 = 1;
MyTree.Level1_.Level2 = 2;
MyTree.Level1_.Level2_.Level3 = 3;
MyTree.Level1_.Level2_.Level3_.Level4 = 4;
xml_write(<span class="string">'test.xml'</span>, MyTree);
fprintf(<span class="string">'Test xml file:\n'</span>);
type(<span class="string">'test.xml'</span>)
</pre><pre class="codeoutput">Test xml file:

&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;MyTree&gt;
   &lt;Level1&gt;1&lt;/Level1&gt;
   &lt;Level1_&gt;
      &lt;Level2&gt;2&lt;/Level2&gt;
      &lt;Level2_&gt;
         &lt;Level3&gt;3&lt;/Level3&gt;
         &lt;Level3_&gt;
            &lt;Level4&gt;4&lt;/Level4&gt;
         &lt;/Level3_&gt;
      &lt;/Level2_&gt;
   &lt;/Level1_&gt;
&lt;/MyTree&gt;
</pre><p><b>Use Default ("Pref.NumLevels = infinity") setting</b></p><pre class="codeinput">tree = xml_read(<span class="string">'test.xml'</span>);
gen_object_display(tree);
</pre><pre class="codeoutput">     Level1: [1]
    Level1_: [1x1 struct]
              Level2: [2]
             Level2_: [1x1 struct]
                       Level3: [3]
                      Level3_: [1x1 struct]
                               Level4: [4]
</pre><p><b>Limit the read to only 2 levels</b></p><pre class="codeinput">Pref=[]; Pref.NumLevels = 2;
tree = xml_read(<span class="string">'test.xml'</span>, Pref);
gen_object_display(tree);
</pre><pre class="codeoutput">     Level1: [1]
    Level1_: [1x1 struct]
              Level2: [2]
             Level2_: [0x0 double]
</pre><h2>Create DOM object based on a Struct using "xml_write"<a name="86"></a></h2>
         <p><b>Create Struct tree</b></p><pre class="codeinput">MyTree=[];
MyTree.MyNumber = 13;
MyTree.MyString = <span class="string">'Hello World'</span>;
</pre><p><b>Convert Struct to DOM object using xml_write</b></p><pre class="codeinput">DOM = xml_write([], MyTree);
xmlwrite(<span class="string">'test.xml'</span>, DOM);   <span class="comment">% Save DOM object using MATLAB function</span>
type(<span class="string">'test.xml'</span>)
</pre><pre class="codeoutput">
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;MyTree&gt;
   &lt;MyNumber&gt;13&lt;/MyNumber&gt;
   &lt;MyString&gt;Hello World&lt;/MyString&gt;
&lt;/MyTree&gt;
</pre><h2>Convert DOM object to Struct using "xml_read"<a name="88"></a></h2><pre class="codeinput">DOM = xmlread(<span class="string">'test.xml'</span>);       <span class="comment">% Read DOM object using MATLAB function</span>
[tree treeName] = xml_read(DOM); <span class="comment">% Convert DOM object to Struct</span>
disp([treeName{1} <span class="string">' ='</span>])
gen_object_display(tree)
</pre><pre class="codeoutput">MyTree =
    MyNumber: [13]
    MyString: 'Hello World'
</pre><h2>Write XML file based on a DOM using "xml_write_xerces"<a name="89"></a></h2><pre class="codeinput">xmlwrite_xerces(<span class="string">'test.xml'</span>, DOM); <span class="comment">% Save DOM object using Xerces library</span>
type(<span class="string">'test.xml'</span>)
</pre><pre class="codeoutput">
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;MyTree&gt;
    &lt;MyNumber&gt;13&lt;/MyNumber&gt;
    &lt;MyString&gt;Hello World&lt;/MyString&gt;
&lt;/MyTree&gt;

</pre><h2>Write XML to string instead of a file<a name="90"></a></h2><pre class="codeinput">DOM = xml_write([], MyTree);
str = xmlwrite(DOM);
disp(str)
</pre><pre class="codeoutput">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;MyTree&gt;
   &lt;MyNumber&gt;13&lt;/MyNumber&gt;
   &lt;MyString&gt;Hello World&lt;/MyString&gt;
&lt;/MyTree&gt;
</pre><h2>Write XML file with embedded binary data encoded as Base64<a name="91"></a></h2><pre class="codeinput">fid = fopen(<span class="string">'football.jpg'</span>, <span class="string">'rb'</span>);
raw = fread(fid, <span class="string">'uint8'</span>);                <span class="comment">% read image file as a raw binary</span>
fclose(fid);

MyTree=[];
MyTree.Size = 13;
MyTree.MyString = <span class="string">'Hello World'</span>; <span class="comment">% simple case</span>
MyTree.MyImage.ATTRIBUTE.EncodingMIMEType = <span class="string">'base64'</span>;
MyTree.MyImage.CONTENT = base64encode(raw);<span class="comment">% perform base64 encoding of the binary data</span>
xml_write(<span class="string">'test.xml'</span>, MyTree);             <span class="comment">% write xml file</span>
</pre><h2>Read XML file with embedded binary data encoded as Base64<a name="92"></a></h2><pre class="codeinput">tree = xml_read(<span class="string">'test.xml'</span>, Pref);         <span class="comment">% read xml file</span>
raw  = base64decode(tree.MyImage.CONTENT); <span class="comment">% convert xml image to raw binary</span>
fid = fopen(<span class="string">'MyFootball.jpg'</span>, <span class="string">'wb'</span>);
fwrite(fid, raw, <span class="string">'uint8'</span>);                 <span class="comment">% dumb the raw binary to the hard disk</span>
fclose(fid);
I = imread(<span class="string">'MyFootball.jpg'</span>);              <span class="comment">% read it as an image</span>
imshow(I);
</pre><img vspace="5" hspace="5" src="xml_tutorial_script_01.png" alt=""> <p class="footer"><br>
            Published with MATLAB&reg; 7.7<br></p>
      </div>
      <!--
##### SOURCE BEGIN #####
%% Tutorial for xml_io_tools Package
% *By Jarek Tuszynski*
%
% Package xml_io_tools can read XML files into MATLAB struct and writes 
% MATLAB data types to XML files with help of simple interface to 
% MATLAB's xmlwrite and xmlread functions.
% 
% Two function to simplify reading and writing XML files from MATLAB:
%
% * Function xml_read first calls MATLAB's xmlread function and than 
% converts its output ('Document Object Model' tree of Java objects) 
% to tree of MATLAB struct's. The output is in the format of nested 
% structs and cells. In the output data structure field names are based on
% XML tags.
%
% * Function xml_write first convert input tree of MATLAB structs and cells 
% and other types to tree of 'Document Object Model' nodes, and then writes 
% resulting object to XML file using MATLAB's xmlwrite function. .
%
%% This package can:
% * Read most XML files, created inside and outside of MATLAB environment, 
%   and convert them to MATLAB data structures.
% * Write any MATLAB's struct tree to XML file
% * Handle XML attributes
% * Handle special XML nodes like comments, processing instructions and 
%   CDATA sections
% * Be studied, modified, customized, rewritten and used in other packages 
%   without any limitations. All code is included and documented. Software
%   is distributed under MIT Licence (included).   
%
%% This package does not:
% * Guarantee to recover the same Matlab objects that were saved. If you 
% need to be able to recover carbon copy of the structure that was saved 
% than you will have to use one of the packages that uses special set of 
% tags saved as xml attributes that help to guide the parsing of XML code. 
% This package does not use those tags.
% * Guarantee to work with older versions of MATLAB. Functions do not work
% with versions of MATLAB prior to 7.1 (26-Jul-2005). Versions starting 
% with 7.1 seem to work on my machine, which have current java engine and 
% libraries. 
%
%% Change History
% * 2006-11-06 - original version
% * 2006-11-26 - corrected xml_write to handle writing Matlab's column
%   arrays to xml files. Bug discovered and diagnosed by Kalyan Dutta.
% * 2006-11-28 - made changes to handle special node types like: 
%   COMMENTS and CDATA sections 
% * 2007-03-12 - Writing CDATA sections still did not worked. The problem 
%   was diagnosed and fixed by Alberto Amaro. The fix involved rewriting
%   xmlwrite to use Apache Xerces java files directly instead of MATLAB's 
%   XMLUtils java class.
% * 2007-06-21 - Fixed problem reported by Anna Kelbert in Reviews about 
%   not writing attributes of ROOT node. Also: added support for Processing
%   Instructions, added support for global text nodes: Processing
%   Instructions and comments, allowed writing tag names with special
%   characters
% * 2007-07-20 - Added tutorial script file. Extended support for global
%   text nodes. Added more Preference fields.
% * 2008-01-23 - Fixed problem reported by Anna Krewet of converting dates 
%   in format '2007-01-01' to numbers. Improved and added warning messages.
%   Added detection of old Matlab versions incompatible with the library.
%   Expanded documentation.
% * 2008-06-23 - Fixed problem with writing 1D array reported by Mark Neil. 
%   Extended xml_read's Pref.Num2Str to 3 settings (never, smart and always) 
%   for better control. Added parameter Pref.KeepNS for keeping or ignoring 
%   namespace data when reading. Fixed a bug related to writing 2D cell
%   arrays brought up by Andrej's Mosat review. 
% * 2008-09-11 - Resubmitting last upload - zip file is still old
% * 2009-02-26 - Small changes. More error handling. More robust in case of
%   large binary objects. Added support for Base64 encoding/decoding of
%   binary objects (using functions by Peter J. Acklam).
% * 2009-06-26 - changes to xml_read: added CellItem parameter to allow
%   better control of reading files with 'item' notation (see comment by
%   Shlomi); changed try-catch statements so xml_read would work for mablab
%   versions prior to 7.5 (see Thomas Pilutti comment)
% * 2009-12-03 - added PreserveSpace parameter for contolling empty string
%   handling as suggested by Sebastiaan. Fix suggested by Michael Murphy.
%   Fixed number recognition code as suggested by Yuan Ren.  
% * 2010-05-04 - implemented fixes suggested by Dylan Reynolds from Airbus.  
%% Licence
% The package is distributed under MIT License
format compact; % viewing preference
clear variables;
type('license.txt')

%% Write XML file based on a Struct using "xml_write"
% Any MATLAB data struct can be saved to XML file.
MyTree=[];
MyTree.MyNumber = 13;
MyTree.MyString = 'Hello World';
xml_write('test.xml', MyTree);
type('test.xml')

%% Read XML file producing a Struct using "xml_read"
[tree treeName] = xml_read ('test.xml');
disp([treeName{1} ' ='])
gen_object_display(tree)

%% "Pref.XmlEngine" flag in "xml_write"
% Occasionaly some operations are performed better by Apache Xerces XML 
% engine than default xmlread function. That is why xml_write provide an 
% option for choosing the underlaying xml engine. Code below performs the 
% same operation as the previous section but using Apache Xerces XML engine.
% Notice that in this case name of root element 
% was passed as variable and not extracted from the variable name.
Pref=[]; Pref.XmlEngine = 'Xerces';  % use Xerces xml generator directly
xml_write('test.xml', MyTree, 'TreeOfMine', Pref);
type('test.xml')

%% Writing Struct with MATLAB arrays
MyTree=[];
MyTree.Num_1x1 = 13;
MyTree.Vec_1x3 = [1 2 3]; 
MyTree.Vec_4x1 = [1; 2; 3; 4]; 
MyTree.Mat_2x2 = [1, 2; 3, 4];         % 2D Matrix
MyTree.Cube_3D = reshape(1:8,[2 2 2]); % 3D array
MyTree.String1 = '[2003 10 30]';       % array with    [] brackets
MyTree.String2 =  '2003 10 30';        % array without [] brackets
xml_write('test.xml', MyTree);
type('test.xml')

%% Read Struct with MATLAB arrays
% Notice that 'Cube_3D' did not preserve original dimentions 
[tree treeName] = xml_read ('test.xml');
disp([treeName{1} ' ='])
gen_object_display(tree)

%% "Pref.StructItem" flag in "xml_write"
% *Create a simple structure with arrays of struct's*
MyTree = [];
MyTree.a(1).b = 'jack';
MyTree.a(2).b = 'john';
gen_object_display(MyTree)
%%
% *Write XML with "StructItem = true" (default).  Notice single 'a' 
% section and multiple 'item' sub-sections. Those subsections are used 
% to store array elements*
wPref.StructItem = true;
xml_write('test.xml', MyTree, 'MyTree',wPref);
type('test.xml')
fprintf('\nxml_read output:\n')
gen_object_display(xml_read ('test.xml'))
%%
% *Write XML with "StructItem = false". Notice multiple 'a' sections*
wPref.StructItem = false;
xml_write('test.xml', MyTree, 'MyTree',wPref);
type('test.xml')
fprintf('\nxml_read output:\n')
gen_object_display(xml_read ('test.xml'))
%%
% *Notice that xml_read function produced the same struct when reading both files*
%%
% *Potential problems with "StructItem = true":*
wPref.StructItem = true;
MyTree1 = []; MyTree1.a.b    = 'jack';
MyTree2 = []; MyTree2.a(1).b = 'jack';
MyTree3 = []; MyTree3.a(2).b = 'jack';
xml_write('test.xml', MyTree1, [], wPref); type('test.xml');
xml_write('test.xml', MyTree2, [], wPref); type('test.xml');
xml_write('test.xml', MyTree3, [], wPref); type('test.xml');
%%
% *Notice that MyTree1 and MyTree2 produce identical files with no 'items',
% while MyTree2 and MyTree3 produce very different file structures. It was
% pointed out to me that files produced from MyTree2 and MyTree3 can not 
% belong to the same schema, which can be a problem. The solution is to use 
% cells.* 
wPref.CellItem = true;
wPref.NoCells  = true;
MyTree2 = []; MyTree2.a{1}.b = 'jack';
MyTree3 = []; MyTree3.a{2}.b = 'jack';
xml_write('test.xml', MyTree2, [], wPref); type('test.xml');
xml_write('test.xml', MyTree3, [], wPref); type('test.xml');


%% "Pref.CellItem" flag in "xml_write"
% *Create a simple structure with cell arrays*
MyTree = [];
MyTree.a = {'jack', 'john'};
disp(MyTree)
%%
% *Write XML with "CellItem = true" (default).  Notice single 'a' 
% section and multiple 'item' sections*
Pref=[]; Pref.CellItem = true;
xml_write('test.xml', MyTree, 'MyTree',Pref);
type('test.xml')
fprintf('\nxml_read output:\n');
disp(xml_read ('test.xml'))
%%
% *Write XML with "CellItem = false". Notice multiple 'a' sections*
Pref=[]; Pref.CellItem = false;
xml_write('test.xml', MyTree, 'MyTree',Pref);
type('test.xml')
fprintf('\nxml_read output:\n');
disp(xml_read ('test.xml'))
%%
% *Notice that xml_read function produced the same struct when reading both files*


%% "Pref.NoCells" flag in "xml_read"
% *Create a cell/struct mixture object*
MyTree = [];
MyTree.a{1}.b = 'jack';
MyTree.a{2}.b = [];
MyTree.a{2}.c = 'john';
gen_object_display(MyTree);
%%
% *Save it to xml file*
Pref=[]; Pref.CellItem = false;
xml_write('test.xml', MyTree, 'MyTree',Pref);
type('test.xml')
%%
% *Read above file with "Pref.NoCells=true" (default) - output is quite different then input*
% By default program is trying to convert everything to struct's and arrays
% of structs. In case arrays of structs all the structs in array need to have the
% same fields, and if they are not than MATLAB creates empty fields.
Pref=[]; Pref.NoCells=true;
gen_object_display(xml_read('test.xml', Pref))
%%
% *Read above file with "Pref.NoCells=false" - now input and output are the same*
% Cell arrays of structs allow structs in array to have different fields.
Pref=[]; Pref.NoCells=false;
gen_object_display(xml_read('test.xml', Pref))

%% "Pref.ItemName" flag in "xml_write"
% *Create a cell/struct mixture object*
MyTree = [];
MyTree.a{1}.b = 'jack';
MyTree.a{2}.c = 'john';
gen_object_display(MyTree);
%%
% *Save it to xml file, using 'item' notation but with different name*
Pref=[]; 
Pref.CellItem = true;
Pref.ItemName = 'MyItem';
xml_write('test.xml', MyTree, 'MyTree',Pref);
type('test.xml')

%% "Pref.ItemName" flag in "xml_read"
% *Read above file with default settings ("Pref.ItemName = 'item'")*
% The results do not match the original structure
Pref=[]; Pref.NoCells  = false;
gen_object_display(xml_read('test.xml', Pref))
%%
% *Read above file with "Pref.ItemName = 'MyItem'" - now saved and read 
% MATLAB structures are the same*
Pref=[]; 
Pref.ItemName = 'MyItem';
Pref.NoCells  = false;
gen_object_display(xml_read('test.xml', Pref))

%% "Pref.CellItem" flag in "xml_read"
% "Pref.ItemName" is used to create xml files with clearly marked arrays
% "Pref.CellItem" flag in "xml_read" ensures that they are always read as
% arrays by forcing output to stay in cell format. In cell format s{1} is
% different than s, while s(1) is indistinguishable from s.
%%
% *Create a test file*
MyTree = [];
MyTree.a1{1}.b = 'jack'; % a1 - single struct
MyTree.a2{1}.b = 'jack'; % a2 - cell array of structs with the same fields
MyTree.a2{2}.b = 'john';
MyTree.a3{1}.b = 'jack'; % a3 - cell array of structs with the different fields
MyTree.a3{2}.c = 'john';
Pref=[]; 
Pref.CellItem = true;
Pref.Debug = true;
xml_write('test.xml', MyTree, 'MyTree',Pref);
type('test.xml')
%%
% *Read above file with "Pref.CellItem = true" (default)*
% All outputs are in cell format
Pref=[]; 
Pref.NoCells  = false;  % allow cell output
Pref.CellItem = true;   % keep 'item' arrays as cells 
gen_object_display(xml_read('test.xml', Pref))
%%
% *Read above file with "Pref.CellItem = false"*
% Outputs format is determined by content
Pref=[]; 
Pref.NoCells  = false; % allow cell output
Pref.CellItem = false; % allow 'item' arrays to beheave like other fields 
gen_object_display(xml_read('test.xml', Pref))
%%
% *Read above file with "Pref.CellItem = false" and "Pref.NoCells  = true"*
% All outputs are in struct format
Pref=[]; 
Pref.NoCells  = true;  % don't allow cell output 
Pref.CellItem = false; % allow 'item' arrays to beheave like other fields
gen_object_display(xml_read('test.xml', Pref))

%% "Pref.Str2Num" flag in xml_read
% *Create a cell/struct mixture object*
MyTree = [];
MyTree.str     = 'sphere';
MyTree.num1    =  123;
MyTree.num2    = '123';
MyTree.num3    = '[Inf,NaN]';
MyTree.calc    = '1+2+3+4';
MyTree.func    = 'sin(pi)/2';
MyTree.String1 = '[2003 10 30]'; 
MyTree.String2 = '2003 10 30';   % array resembling date
MyTree.ISO8601 = '2003-10-30';   % date in ISO 8601 format
MyTree.US_date = '2003/10/30';   % US style date format
MyTree.complex = '2003i-10e-30'; % complex number resembling a date
gen_object_display(MyTree);
%%
% *Save it to xml file*
xml_write('test.xml', MyTree);
type('test.xml')
%%
% *Read above file with default settings*
% ("Pref.Str2Num = true" or "Pref.Str2Num = 'smart'"). Under this setting all
% strings that look like numbers are converted to numbers, except for 
% strings that are recognized by MATLAB 'datenum' function as dates
gen_object_display(xml_read('test.xml'))
%%
% *Note that all the fields of 'MyTree' can be converted to numbers (even 
% 'sphere') but by default the function is trying to 'judge' if a string  
% should be converted to a number or not*
MyCell = {'sphere','1+2+3+4','sin(pi)/2','2003 10 30','2003-10-30','2003/10/30','2003i-10e-30'};
cellfun(@str2num, MyCell, 'UniformOutput', false)
%%
% *Read above file with "Pref.Str2Num = false" or "Pref.Str2Num = 'never'" 
% to keep all the fields in string format*
Pref=[]; Pref.Str2Num = false;
gen_object_display(xml_read('test.xml', Pref))
%%
% *Read above file with "Pref.Str2Num = always"  
% to convert all strings that look like numbers to numbers* note the likelly 
% unintendet conversion of 'ISO8601'
Pref=[]; Pref.Str2Num   = 'always';
gen_object_display(xml_read('test.xml', Pref))
%%
% *Notice that all three settings will produce the same output for "num1" and
% "num2" and there is no way to reproduce the original "MyTree" structure.*

%% "Pref.PreserveSpace" flag in xml_write
% *Create a struct with strings*
MyTree=[];
MyTree.Empty     = '';
MyTree.OneSpace  = ' ';
MyTree.TwoSpaces = '  '; 
MyTree.String1   = ' Hello      World ';
%%
% *Write XML with "PreserveSpace = false" (default).*
Pref=[]; Pref.PreserveSpace = false; % (default setting)
xml_write('test.xml', MyTree, [], Pref);
type('test.xml')
%%
% *Write XML with "PreserveSpace = true".*
Pref=[]; Pref.PreserveSpace = true; 
xml_write('test.xml', MyTree, [], Pref);
type('test.xml')

%% "Pref.PreserveSpace" flag in xml_read
% *Read file while using "PreserveSpace = false" (default).*
Pref=[]; Pref.PreserveSpace = false; % (default setting)
gen_object_display(xml_read('test.xml',Pref))
%%
% *Read file while using "PreserveSpace = true".*
Pref=[]; Pref.PreserveSpace = true; 
gen_object_display(xml_read('test.xml',Pref))


%% Write XML files with ATTRIBUTEs 
% In order to add node attributes a special ATTRIBUTE field is used. 
% ATTRIBUTEs have to be of simple types like numbers or strings (not
% struct or cells). Attributes are easy to attach to structs nodes like 
% MyTree below. 
MyTree=[];
MyTree.MyNumber = 13;
MyTree.MyString = 'Hello World'; % simple case
MyTree.ATTRIBUTE.Num = 2;
xml_write('test.xml', MyTree);
type('test.xml')

%%  
% In case when one needs to attach attributes to nodes which are not
% structs (for example strings, numbers or calls) then special CONTENT 
% field needs to be used to make the node a struct node.
MyTree=[];
MyTree.MyNumber = 13;
MyTree.MyString.CONTENT = 'Hello World'; % simple case
MyTree.MyString.ATTRIBUTE.Num = 2;
xml_write('test.xml', MyTree);
type('test.xml')

%% "Pref.Str2Num" flag in file with ATTRIBUTEs
% *Create a cell/struct mixture object*
MyTree = [];
MyTree.X.ATTRIBUTE.str     = 'sphere';
MyTree.X.ATTRIBUTE.num1    =  123;
MyTree.X.ATTRIBUTE.num2    = '123';
MyTree.X.ATTRIBUTE.num3    = '[Inf,NaN]';
MyTree.X.ATTRIBUTE.calc    = '1+2+3+4';
MyTree.X.ATTRIBUTE.func    = 'sin(pi)/2';
MyTree.X.ATTRIBUTE.String1 = '[2003 10 30]'; 
MyTree.X.ATTRIBUTE.String2 = '2003 10 30';   % array resembling date
MyTree.X.ATTRIBUTE.ISO8601 = '2003-10-30';   % date in ISO 8601 format
MyTree.X.ATTRIBUTE.US_date = '2003/10/30';   % US style date format
MyTree.X.ATTRIBUTE.complex = '2003i-10e-30'; % complex number resembling a date
gen_object_display(MyTree);
%%
% *Save it to xml file*
xml_write('test.xml', MyTree);
type('test.xml')
%%
% *Read above file with default settings*
% ("Pref.Str2Num = true" or "Pref.Str2Num = 'smart'"). Under this setting all
% strings that look like numbers are converted to numbers, except for 
% strings that are recognized by MATLAB 'datenum' function as dates
gen_object_display(xml_read('test.xml'))

%%
% *Read above file with "Pref.Str2Num = false" or "Pref.Str2Num = 'never'" 
% to keep all the fields in string format*
Pref=[]; Pref.Str2Num = false;
gen_object_display(xml_read('test.xml', Pref))
%%
% *Read above file with "Pref.Str2Num = always"  
% to convert all strings that look like numbers to numbers* 
Pref=[]; Pref.Str2Num   = 'always';
gen_object_display(xml_read('test.xml', Pref))
%%
% *Notice that all three settings will produce the same output for "num1" and
% "num2" and there is no way to reproduce the original "MyTree" structure.*


%% Write XML files with COMMENTs
% Insertion of Comments is done with help of special COMMENT field.
% Note that MATLAB's xmlwrite is less readable due to lack of end-of-line 
% characters around comment section. 
MyTree=[];
MyTree.COMMENT = 'This is a comment';
MyTree.MyNumber = 13;
MyTree.MyString.CONTENT = 'Hello World';
xml_write('test.xml', MyTree);
type('test.xml')

%%
% *Same operation using Apache Xerces XML engine*
% gives the same result
Pref=[]; Pref.XmlEngine = 'Xerces';  % use Xerces xml generator directly
xml_write('test.xml', MyTree, 'MyTree', Pref);
type('test.xml')

%%
% *Comments in XML top level (method #1)*
% This method uses cell array 
MyTree=[];
MyTree.MyNumber = 13;
MyTree.MyString = 'Hello World';
xml_write('test.xml', MyTree, {'MyTree', [], 'This is a global comment'});
type('test.xml')
%%
% *Same operation using Apache Xerces XML engine* 
% gives even nicer results.
Pref=[]; Pref.XmlEngine = 'Xerces';  % use Xerces xml generator directly
xml_write('test.xml', MyTree, {'MyTree', [], 'This is a global comment'}, Pref);
type('test.xml')

%%
% *Comments in XML top level (method #2)*
% This method adds an extra top layer to the struct 'tree' and sets
% "Pref.RootOnly = false", which informs the function about the extra 
% layer. Notice that RootName is also saved as a part of
% the 'tree', and does not have to be passed in separately.
MyTree=[];
MyTree.COMMENT = 'This is a global comment';
MyTree.MyTest.MyNumber = 13;
MyTree.MyTest.MyString = 'Hello World';
Pref=[]; Pref.RootOnly = false;
xml_write('test.xml', MyTree, [], Pref);
type('test.xml')
%%
% *Same operation using Apache Xerces XML engine*
Pref=[]; Pref.XmlEngine = 'Xerces';  % use Xerces xml generator directly
Pref.RootOnly  = false;
xml_write('test.xml', MyTree, [], Pref);
type('test.xml')

%% Write XML files with PROCESSING_INSTRUCTIONs 
% Insertion of Processing Instructions is done through use of special 
% PROCESSING_INSTRUCTION field, which stores the instruction string. The
% string has to be in 'target data' format separated by space.
MyTree=[];
MyTree.PROCESSING_INSTRUCTION = 'xml-stylesheet type="a" href="foo"';
MyTree.MyNumber = 13;
MyTree.MyString = 'Hello World';
xml_write('test.xml', MyTree);
type('test.xml')

%%
% *Same operation using Apache Xerces XML engine*
Pref=[]; Pref.XmlEngine = 'Xerces';  % use Xerces xml generator directly
xml_write('test.xml', MyTree, 'MyTree', Pref);
type('test.xml')

%%
% *PROCESSING_INSTRUCTIONs in XML top level (method #1)*
% This method uses cell array 
MyTree=[];
MyTree.MyNumber = 13;
MyTree.MyString = 'Hello World';
xml_write('test.xml', MyTree, {'MyTree', 'xml-stylesheet type="a" href="foo"'});
type('test.xml')
%%
% *Same operation using Apache Xerces XML engine*
Pref=[]; Pref.XmlEngine = 'Xerces';  % use Xerces xml generator directly
xml_write('test.xml', MyTree, {'MyTree', 'xml-stylesheet type="a" href="foo"'}, Pref);
type('test.xml')

%%
% *PROCESSING_INSTRUCTIONs in XML top level (method #2)*
% This method adds an extra top layer to the struct 'tree' and sets
% pref.RootOnly=false, which informs the function about the extra 
% layer. Notice that RootName is also saved as a part of
% the 'tree', and does not have to be passed in separately.
MyTree=[];
MyTree.PROCESSING_INSTRUCTION =  'xml-stylesheet type="a" href="foo"';
MyTree.MyTest.MyNumber = 13;
MyTree.MyTest.MyString = 'Hello World';
Pref=[]; Pref.RootOnly = false;
xml_write('test.xml', MyTree, [], Pref);
type('test.xml')
%%
% *Same operation using Apache Xerces XML engine*
Pref=[]; Pref.XmlEngine = 'Xerces';  % use Xerces xml generator directly
Pref.RootOnly  = false;
xml_write('test.xml', MyTree, 'MyTree', Pref);
type('test.xml')

%% Write XML files with CDATA Sections 
% "In an XML document a CDATA (Character DATA) section is a section of 
%  element content that is marked for the parser to interpret as only 
%  character data, not markup." (from Wikipedia) 
% To insert CDATA Sections one use special CDATA_SECTION field,
%  which stores the instruction string. Note that MATLAB's xmlwrite created
%  wrong xml code for CDATA section
MyTree=[];
MyTree.CDATA_SECTION = '<A>txt</A>';
MyTree.MyNumber = 13;
MyTree.MyString = 'Hello World';
xml_write('test.xml', MyTree);
type('test.xml')
%%
% *Same operation using Apache Xerces XML engine produces correct results*
Pref=[]; Pref.XmlEngine = 'Xerces';  % use Xerces xml generator directly
xml_write('test.xml', MyTree, 'MyTree', Pref);
type('test.xml')

%% Write XML files with special characters in TAG names
% The input to xml_write requires that all tags one wants in XML document 
% have to be encoded as field names of MATLAB's struct's. Matlab has a lot
% of restrictions on variable names. This section is about XML tags with
% names not allowed as MATLAB variables, or more specifically with
% characters allowed as xml tag names but not allowed as MATLAB variable
% names. Characters like that can be replaced by their hexadecimal
% representation just as it is done by genvarname function. Alternative way
% of writing the first example is:
MyTree=[];
MyTree.('MyNumber') = 13;               % same as MyTree.MyNumber = 13;
MyTree.MyString.CONTENT = 'Hello World';
MyTree.MyString.ATTRIBUTE.('Num') = 2;  % same as MyTree.MyString.ATTRIBUTE.Num = 2;
xml_write('test.xml', MyTree);
type('test.xml')

%%
% *This approach fails for some characters like dash '-', colon ':', and
% international characters.*
MyTree=[];
try
  MyTree.('My-Number') = 13;
  MyTree.MyString.CONTENT = 'Hello World';
  MyTree.MyString.ATTRIBUTE.('Num_ö') = 2;
catch  %#ok<CTCH>
  err = lasterror; %#ok<LERR>
  disp(err.message);
end

%%
% It can be overcome by replacing offending characters with their 
% hexadecimal representation. That can be done manually or with use of 
% genvarname function. Note that MATLAB 'type' function does not show
% correctly 'ö' letter in xml file, but opening the file in editor shows 
% that it is correct.
MyTree=[];
MyTree.(genvarname('My-Number')) = 13;
MyTree.MyString.CONTENT = 'Hello World';
MyTree.MyString.ATTRIBUTE.Num_0xF6 = 2;
gen_object_display(MyTree);
xml_write('test.xml', MyTree);
type('test.xml')

%%
% *Also two of the characters '-' and ':' can be encoded by a special strings:
% '_DASH_' and '_COLON_' respectively*
MyTree=[];
MyTree.My_DASH_Number = 13;
MyTree.MyString.CONTENT = 'Hello World';
MyTree.MyString.ATTRIBUTE.Num0xF6 = 2;
xml_write('test.xml', MyTree);
type('test.xml')

%% Write XML files with Namespaces
% No extra special fields are needed to define XML namespaces, only colon 
% character written using '0x3A' or '_COLON_'. Below is an
% example of a namespace definition
MyTree=[];
MyTree.f_COLON_child.ATTRIBUTE.xmlns_COLON_f = 'http://www.foo.com';
MyTree.f_COLON_child.f_COLON_MyNumber = 13;
MyTree.f_COLON_child.f_COLON_MyString = 'Hello World';
xml_write('test.xml', MyTree, 'MyTree');
type('test.xml')
%%
% *Same operation using Apache Xerces XML engine*
Pref=[]; Pref.XmlEngine = 'Xerces';  % use Xerces xml generator directly
xml_write('test.xml', MyTree, 'f_COLON_MyTree', Pref);
type('test.xml')

%% "Pref.KeepNS" flag in "xml_read"
% Thise option allow keeping  or exclusion of namespaces in tag names. 
% By default the namespace data is kept but it produces much longer field
% names in the output structure. Ignoring namespace will produce more
% readible output.
% Perform default read of file with namespace
tree = xml_read('test.xml');
gen_object_display(tree);

%%
% Now the same operation with KeepNS = false. 
Pref=[]; Pref.KeepNS = false; % do not read attributes
tree = xml_read('test.xml', Pref);
gen_object_display(tree);

%% Read XML files with special node types
% Display and read the file, then show the data structure. Note that 
% MATLAB 'type' function shows 'ö' letter incorrectly as 'A¶' in xml file, 
% but opening the file in editor shows that it is correct.
fprintf('Test xml file:\n');
type('test_file.xml')
%%
% Read only the Root Element (default) 
[tree GlobalTextNodes] = xml_read('test_file.xml');
fprintf('Global Data (Root name, Global Processing Instructions and Global Comments):\n');
disp(GlobalTextNodes')
fprintf('\nStructure read from the file (uncludes COMMENT and CDATA sections):\n');
gen_object_display(tree);
%%
% Read the whole tree including global Comments and Processing Instructions
Pref=[]; Pref.RootOnly = false;
[tree GlobalTextNodes] = xml_read('test_file.xml', Pref);
fprintf('Global Data (Root name, Global Processing Instructions and Global Comments):\n');
disp(GlobalTextNodes')
fprintf('\nStructure read from the file (uncludes COMMENT and CDATA sections):\n');
gen_object_display(tree);

%% "Pref.ReadAttr" flag in "xml_read"
% Those option allow exclusion of attributes 
Pref=[]; Pref.ReadAttr = false; % do not read attributes
tree = xml_read('test_file.xml', Pref);
gen_object_display(tree);

%% "Pref.ReadSpec" flag in "xml_read"
% Those option allow exclusion of special nodes, like
% comments, processing instructions, CData sections, etc.
Pref=[]; Pref.ReadSpec = false; % do not read special node types
tree = xml_read('test_file.xml', Pref);
gen_object_display(tree);

%% "Pref.RootOnly" flag in "xml_read"
% As it was shown in previous examples RootOnly parameter can be used to
% capture global (top level) special nodes (like COMMENTs and
% PROCESSING_INSTRUCTIONs) which are ignored by default
Pref=[]; Pref.RootOnly = false; % do not read special node types
tree = xml_read('test_file.xml', Pref);
gen_object_display(tree);

%% "Pref.RootOnly" flag in "xml_write"
% Writing previously read tree with default "Pref.RootOnly = true" gives
% wrong output file
Pref=[]; Pref.RootOnly = true; % do not read special node types
xml_write('test.xml', tree, [], Pref);
fprintf('Test xml file:\n');
type('test.xml')
%%
% Writing the same tree with "Pref.RootOnly = false" gives correct output
Pref=[]; Pref.RootOnly = false; % do not read special node types
xml_write('test.xml', tree, [], Pref);
fprintf('Test xml file:\n');
type('test.xml')

%% "Pref.NumLevels" flag in "xml_read"
% This parameter allows user to skip parts of the tree in order to save
% time and memory. Usefull only in a rare case when a small portion of
% large XML file is needed.
%
% Create test tile
MyTree = [];
MyTree.Level1 = 1;
MyTree.Level1_.Level2 = 2;
MyTree.Level1_.Level2_.Level3 = 3;
MyTree.Level1_.Level2_.Level3_.Level4 = 4;
xml_write('test.xml', MyTree);
fprintf('Test xml file:\n');
type('test.xml')
%%
% *Use Default ("Pref.NumLevels = infinity") setting*
tree = xml_read('test.xml');
gen_object_display(tree);
%%
% *Limit the read to only 2 levels*
Pref=[]; Pref.NumLevels = 2; 
tree = xml_read('test.xml', Pref);
gen_object_display(tree);




%% Create DOM object based on a Struct using "xml_write"
% *Create Struct tree*
MyTree=[];
MyTree.MyNumber = 13;
MyTree.MyString = 'Hello World';
%%
% *Convert Struct to DOM object using xml_write*
DOM = xml_write([], MyTree); 
xmlwrite('test.xml', DOM);   % Save DOM object using MATLAB function 
type('test.xml')

%% Convert DOM object to Struct using "xml_read"
DOM = xmlread('test.xml');       % Read DOM object using MATLAB function
[tree treeName] = xml_read(DOM); % Convert DOM object to Struct
disp([treeName{1} ' ='])
gen_object_display(tree)

%% Write XML file based on a DOM using "xml_write_xerces"
xmlwrite_xerces('test.xml', DOM); % Save DOM object using Xerces library 
type('test.xml')

%% Write XML to string instead of a file
DOM = xml_write([], MyTree);
str = xmlwrite(DOM);
disp(str)

%% Write XML file with embedded binary data encoded as Base64
fid = fopen('football.jpg', 'rb');       
raw = fread(fid, 'uint8');                % read image file as a raw binary
fclose(fid);

MyTree=[];
MyTree.Size = 13;
MyTree.MyString = 'Hello World'; % simple case
MyTree.MyImage.ATTRIBUTE.EncodingMIMEType = 'base64';
MyTree.MyImage.CONTENT = base64encode(raw);% perform base64 encoding of the binary data
xml_write('test.xml', MyTree);             % write xml file

%% Read XML file with embedded binary data encoded as Base64
tree = xml_read('test.xml', Pref);         % read xml file
raw  = base64decode(tree.MyImage.CONTENT); % convert xml image to raw binary
fid = fopen('MyFootball.jpg', 'wb');  
fwrite(fid, raw, 'uint8');                 % dumb the raw binary to the hard disk 
fclose(fid);
I = imread('MyFootball.jpg');              % read it as an image
imshow(I);
##### SOURCE END #####
-->
   </body>
</html>